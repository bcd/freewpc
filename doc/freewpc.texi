\input texinfo
@c %**start of header
@setfilename freewpc.info
@settitle The FreeWPC Manual
@setchapternewpage odd
@c %**end of header

@set VERSION 1.10-dev
@set COPYRIGHT 2006-2010

@titlepage
@title The FreeWPC Manual
@author Brian Dominy

@sp 10
@center @titlefont{}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} @value{COPYRIGHT} by Brian Dominy.
@end titlepage

@contents

@ifnottex
@node Top
@top Introduction

This is the manual for @dfn{FreeWPC}, a free platform for developing replacement
game ROMs for Bally/Williams pinball machines based on the WPC
(Williams Pinball Controller) chip.  FreeWPC provides the foundation for building
new ROMs with custom game rules.  This document describes version
@value{VERSION} of the software.

FreeWPC is developed by Brian Dominy (@email{brian@@oddchange.com}) and is licensed
under the GNU General Public License version 2 or later.  The latest version of
the software can be obtained at @url{http://www.oddchange.com/freewpc}.
Developers should be familiar
with basic embedded systems programming concepts and the C programming
language.  Familiarity with 6809 assembler is recommended but not necessary.
Also, knowledge of WPC pinball machines is very helpful.

@end ifnottex

@menu
* Overview::                A basic description of what FreeWPC is.
* Installation::            How to obtain and install the software.
* Compiling::               How to recompile the code yourself.
* Software Environment::    The basic software model.
* Core APIs::               How to control the hardware from user code.
* Effects::                 How to choreograph lights, sounds, and graphics.
* Ball Tracking::           How the locations of the pinballs are monitored.
* Test Mode::               Differences in the service menu.
* Common Pinball Library::  Other common functions that are implemented.
* Fonts and Graphics::      More info on the display APIs.
* System Initialization::   The sequence of events that happen at startup.
* Platform APIs::           How to define a new hardware platform.
* Native Mode::             Running the software directly on your PC.
* Debugging::               How to debug problems.
* The WPC Hardware::        A primer on the WPC platform.
* The Machine Definition::  How to define a new machine.
* System Events::           A list of the predefined callback functions.
* Build Tools::             Other programs used during the build process.
* Dot-Matrix Performance::  Thoughts on optimization of the display.
* Historical Notes::        Random observations from past experience.
* Design Principles::       Common practices for creating new game modules.
* Concept Index::
@end menu

@ignore
* Frame Rate::
* Simulating Color::
* 6809 Instruction Set::
* The Fastest Copy in Town::
* Bit Alignment::
* Compression Techniques::
* Binary Packages::
* Source Code Packages::
* Directory Layout::
* Configuration::
* Making the ROM::

@menu
* Switches::
* Lamps::
* Power Drivers::
* Zerocross Detector::
* Dot-Matrix Display (DMD)::
* Sound Board::
* Triacs and General Illumination::
* Real-Time Clock::
* High Precision Timer::
* Miscellaneous::
* Debug Port::
* Paging and Locking::
* Bit Shifting::
@end menu

@menu
* Device Status::
* Global Status::
* Events::
* The Trough Device::
@end menu

* Adjustments::
* Audits::
* Tests::
* Development::

* Coins and Pricing::
* Ball Devices::
* Extra Balls::
* High Scores::
* Enter Initials::
* Tournament Mode::
* Ball Search::
* Knocker Driver::
* PIC Driver::
* Player Local Data::
* Adjustments::
* Audits::
* Scoring::

* Compression::
* Using TrueType Fonts::
* Frame List::

* @command{wpcdebug} and @command{PinMAME}::
* @command{gdb}::
* @command{exec09}::
* @command{Breakpoints}::
* @command{csum} : ROM Checksum Tool::
* @command{srec2bin} : S-Record Converter::
* @command{sched} : Static Scheduler::
* @command{fontgen2} : TrueType Font Generator::

* Overview::
* CPU Board::
* Power Driver Board::
* Sound Board::
* Fliptronic Board::
* Auxiliary Driver Board::
* Dot Matrix Controller Board::
* Memory Map::

* Syntax::
* Fixed Objects::
* Variable Objects::
* Directives::
* Global Configuration::
* Section Summary::
* How genmachine works::
@end ignore

@node Overview
@chapter Overview

FreeWPC is a toolkit for building brand new software for pinball machines.
It primarily targets the Williams WPC
family of games, which was used in all of that company's games from 1990-1999,
starting with @samp{Funhouse} and ending with @samp{Cactus Canyon}.

This document provides an overview of the FreeWPC architecture for
developers who wish to understand how the system works.
FreeWPC is constantly evolving and the information here is
subject to change.

FreeWPC only replaces your game ROM (the U6 chip on the CPU board), which contains all
of the game code and dot matrix text/graphics.  In particular, sounds and
music are NOT included in this device, so FreeWPC games use the
same sounds as the real machines.

@cindex Legalese
FreeWPC is 100% Williams-free code, written from scratch.  It is not a hack on existing
ROMs and does not contain any software extracted from real games.
Most of the code is written mostly in the C programming language.  (Actual WPC games
were programmed in assembly language).  FreeWPC uses the freely available GCC6809 C
compiler.  There are some assembly language routines for really low-level, or high
performance parts of the program.

@cindex WPC generations
All generations of WPC are supported.  FreeWPC is also architected into a number of
distinct layers which makes it highly portable to other
types of pinball machines than just WPC games, including new custom hardware.  The
@emph{platform} files describe the circuit boards.  The @emph{CPU} files are specific to
the microprocessor, and can be shared between platforms (WPC and WhiteStar both use
a 6809).  The @emph{machine} files are unique to a particular game.

@cindex Cygwin
Development requires a UNIX-like environment, such as Linux or Cygwin for Microsoft Windows
users.  Many common UNIX tools like @command{bc} and @command{perl} are required.

FreeWPC has become more portable over the years, so that it can be used to develop
pinball software for platforms other than WPC.  This support is still evolving rapidly.
In addition to building ROMs, the toolkit supports @dfn{native mode compilation}, which
builds an executable that can be run directly on your development machine.  This lets you
test and debug the software without requiring a real machine or even an emulator.  Basically,
native mode replaces the lowest level of hardware access with builtin emulation.  In place
of actual I/O being controlled, it displays the results of the simulation on your screen,
using either the console, @command{ncurses}, or @command{gtk}.

@node Installation
@chapter Installation

This chapter explains how to install the software.

FreeWPC is mainly a toolkit, and thus is provided in source code format.
However, periodically binary ROMs are compiled and published as well.
If you are not a developer, but would like to experiment with FreeWPC,
you can just download the binary packages and install them in your
machine or in your emulator.

If you are a developer and want to write your own game code, for one
of the existing games that FreeWPC has been ported to or for a brand
new game, you need a source code package.

If you just want to browse the source code, you can view it online
at the GitHub repository.

@section Binary Packages

Binary packages are available as @file{.zip} files, which contain
@file{.rom} files.  These ROMs replace the game ROM only (the U6 chip
on the CPU board).  If you want to test in a real machine, you need
to burn a real EPROM from this file.

@cindex PinMAME
If you want to test under PinMAME, you need to copy the ROM file into
your PinMAME @file{roms} directory; where this is
depends on how you installed PinMAME.  These directories typically contain
@file{.zip} files of both the game ROM and sound ROMs together.
You'll need to unzip the original file, replace the game ROM, then zip it back.
Make sure to save your original
game ROM file for when you want to revert back to the Williams code.

@section Source Code Packages

The following is a partial list of other programs which are used during the
build process: gcc6809, dd, bc, zip, unzip, bash, Perl.

@section Directory Layout
@cindex Directory structure

The FreeWPC source code tree is organized into the following directories:

@table @file

@item kernel/

The core pinball APIs, which are the user-level APIs used to read inputs and
control outputs.  As a game developer you mostly use the core APIs to interface
to the hardware of the machine.

On hardware which requires bank switching (like WPC), these functions are kept
in the fixed region of ROM that can be called at any time.

@item common/

Secondary pinball APIs, also called the @dfn{Common Pinball Library}.
These functions are not in fixed ROM and may require bank switching to call.

They are mostly software-related APIs for common features that pinball machines have,
like replay, match, and dot-matrix effects.

@item machine/@var{machine}/

The machine-specific files.  Every machine has its own directory of files that are
specific to it.  Each file may or may not be placed into a bank switched region.
Generally, you should put game code outside the fixed page as rules are not important
enough to keep in system ROM.  Custom device drivers must go into system ROM though.

@item platform/@var{platform}/

The platform-specific files.  These are mostly used during initialization.
Every new pinball hardware platform must define some files here.

@item cpu/@var{cpu}/

The CPU-specific files.  For the 6809, these are mostly assembly language files
which are optimized for high performance.  There are also native versions here
when compiling in simulation mode.

@item fonts/

All font files are kept here.  Fonts are stored as normal C code that is compiled
as usual, just with a .fon extension to denote that they are actually fonts.
These files are autogenerated from more standard font files (like TrueType fonts)
and then cleaned up.

@item drivers/

Driver templates for things like jets, slings, kickbacks, etc.  These can be
shared across all machines.

@item include/

All of the include files are kept in here or one of its subdirectories.

@item build/

Most output files which are not under source control, but generated during the
build process, appear here.

@end table

@node Compiling
@chapter Compiling

@section Configuration
@cindex Configuration

FreeWPC can be compiled in many different ways with lots of optional features.
You cannot just type @command{make} at the top of the directory tree without
first specifying what you want to build.  This is done by creating a file
named @file{.config}.  The file @file{config.example} is provided as an
example of the kinds of things that can be tuned.

@file{.config} is written in standard Makefile syntax.  (The top-level
Makefile includes this file.)  You set various options by writing
variable assignments, such as:

@example
MACHINE := wcs
@end example

You must specify at least a @var{MACHINE}.  All other configuration
variables are optional; suitable defaults will be used.

Here is a list of the most important build options.

@table @code
@item MACHINE

Names the machine that you want to build for.  This corresponds to the
name of the subdirectory in the @file{machine} directory that has the
machine specific files.

@item MAKEFLAGS

This is a feature of the @command{make} utility, not FreeWPC per se, but
it can be useful: if you want to pass special flags to @command{make},
include them here.  In particular, the @option{-j} option can be used to
run multiple commands in parallel, which can speed up the build
significantly.

@item FREEWPC_DEBUGGER

Set to @code{y} if you want to include debug messages in the build.

@item CONFIG_BPT

Set to @code{y} if you want to enable the breakpoint module.

@item GCC_VERSION

Used only when building for the 6809 target, this lets you specify the
version of the GCC6809 compiler.

@item EXTRA_CFLAGS

Used to pass arbitrary options to the C compiler.  If you add special
logic to the code under an @code{#ifdef}, you can enable those flags
by including them in @code{EXTRA_CFLAGS}.

@item DEBUG_COMPILER

Set to @code{y} if you are debugging the 6809 compiler.  This causes
many temporary files to be saved for later analysis.

@item SAVE_ASM

Set to @code{y} if you just want to see the assembly language code that
GCC6809 generates.  This is similar to @code{DEBUG_COMPILER} but produces
much less GCC internals.  If you understand 6809 assembly language, this
can be useful.

@item NATIVE

Set to @code{y} to enable native mode, or simulation.

@item CONFIG_UI

In native mode, this option controls the user-interface that is used.
The default is curses, which works within most internals and is fairly
easy to understand.  Use @code{console} for a much more raw, @code{printf}
style output.  @code{gtk} support is in progress.

@item PINMAME

Set to the pathname where your PinMAME executable is, if you plan to
use that for testing.

@item EXTRA_PINMAME_FLAGS

Set to flags that you want to pass to PinMAME when testing; for example,
sound driver options or DMD color schemes.

@item TARGET_ROMPATH

Set to the directory where PinMAME ROM files are kept.

@end table

@section Building

After configuring, type @command{make}.  This will build a ROM and optionally
install it into your PinMAME ROM directory if you have said where that is.

The exact commands are not printed, but you can force the details to be
shown by setting the environment variable @var{Q} to the empty string, like
this:

@example
make Q=""
@end example

The build procedure is complicated, but it can be broken down into the
following steps:

@enumerate

@item Create Blank File

If the size of the ROM is larger than the number of pages that
the compiler generates, then the final ROM image must be
padded with blank sections.  The @command{dd} command is used
to generate a file named @file{blank@var{xxx}.bin}, where @var{xxx}
is the size of the file in kilobytes (KB).  This file
is later concatenated with the linker output to produce
a final ROM of the required size.

@item Create Linker Command Files

The linker is invoked several times, once per page or
bank of ROM.  Different options are passed each time
to place the correct object files into that section, and
to resolve references correctly.  All of these options
are written to linker command files, which have the .lnk
extension and are placed in the @file{build} directory.
They are lists of command-line options to the linker,
but placed into a file because of the huge number of them.

@item Setting the Machine Symbolic Links

The symbol link @file{mach} is set to point to the correct
machine code directory, based on the value of the MACHINE
make variable.  Likewise, @file{include/mach} is pointed to the
machine includes.

@item Generating Defines

Some #defines are generated automatically by scanning the
code for their uses.  These include files begin with the prefix
@command{gendefine} and are created by a script also named
@command{gendefine} in the @file{tools} directory.

At present this is only used to autogenerate the task group IDs.

@item Generating Callsets

Callsets are a mechanism for implementing a simple
event subscription/invocation mechanism that is fully
described at compile-time.  Event handling code is
emitted in a C file named @file{callset.c}.

@item Compiling and Assembling Source Code

Source code is compiled using the GCC6809 compiler.
The compiler generates assembler code with the @file{.s}
extension.  These files are then assembled using the
asxxxx asembler tools into object files with the @file{.o}
extension.

@item Compiling Page Headers

Because the linker requires each section to contain at
least one object file, a dummy file is assembly per
section to ensure that this doesn't happen.  The page
header is 1 byte long and contains the page number.

@item Linking Pages

The aslink utility is used to create one S-record file,
with the @file{.s19} extension, for each page of ROM.

@item Converting Pages to Binary

The @file{tools/srec2bin} utility included with FreeWPC
is run to convert the S-records into raw binary files.

@item Concatenating Pages

The binary files are concatenated, along with any blank
files, to form the final ROM image.

@end enumerate

@section Build Results

If successful, @file{build/@var{var}.rom} will contain the ready-to-burn ROM image.  @var{var} is
a string composed of the machine's short name and the version number.

Warnings and errors during the build are display on the console as they
occur; they are also log to a file named @file{err}.

In native mode, instead of a ROM, a file named @file{freewpc_@var{var}} is generated.


@c ======================================================
@node Software Environment
@chapter Software Environment

FreeWPC provides a standalone operating system environment when compiling
to run on real hardware.  It does not require the use of any
existing OS and has its own multitasker and memory manager.  This chapter
describes the key features of the FreeWPC programming environment.

@menu
* Multitasking::           The normal process model
* Real-Time Processing::   How to schedule realtime tasks
* Memory Allocation::      How to allocate and initialize variables
* Bit Variables::          Declaring 1-bit variables
* Event Handling::         Throwing and catching events
* Template Drivers::       Writing reusable software blocks
* Fault Detection::        Handling serious errors
* Timers::                 The many implementations of timers to choose from
* Bank Switching::         How code is arranged in different banks of ROM
@end menu

@node Multitasking
@section Multitasking

@cindex Task scheduler
FreeWPC implements a runtime, round-robin, non-preemptive task scheduler.
The system manages multiple tasks, each of which has its own call stack.  You
can create a new task when you want to run some code in parallel with the current
thread of execution.  The current task has complete control of the CPU and will
continue to run until it explicitly exits or sleeps (waiting for a certain amount
of time).  The minimum sleep time is defined by IRQS_PER_TICK and is currently 16ms.

Contrast this with desktop operating systems, which use timeslicing and preemption to
allow multiple threads to run in parallel.  There, the OS switches between the tasks.
In FreeWPC task switches only happen explicitly; this provides for more deterministic
behavior, it requires less overhead, and it eliminates the need for mutexes (locks)
between two tasks because task switches cannot happen at arbitrary times.

If a task does not give up control, either by sleeping, exiting, or yielding
after a certain amount of time, the fatal error @code{ERR_FCFS_LOCKUP} will be asserted.

When a new task is created, it does not begin running immediately; control always
continues with the task that started it.  This allows you to configure the new task
before it can run.

@cindex Process IDs
@cindex Group IDs
Each task is identified by a @dfn{process ID}, or @dfn{pid}.  The PID for a task
is assigned by the system when it is created.  A task also has a @dfn{group ID},
or @dfn{gid}.  The GID is assigned by the programmer, and multiple tasks can share
the same GID.  GIDs allow you to control a group of related tasks, or to
refer to a task using a compile-time ID as opposed to a run-time ID.

In native mode, the multitasking APIs are implemented using the GNU
Pth library.  A good description of this library can be found at
@url{http://www.gnu.org/software/pth/}.  Note this is not the same
as @command{pthreads}, which is the predominant @emph{preemptive}
threading library.

For Windows programmers, this threading model is very similar to what Win32 calls
@emph{fibers}.

@subsection Periodic Functions
@cindex Periodic functions

After all tasks have been given a chance to run in a 16ms timeslice,
the system runs the @dfn{periodic functions}.  These have equal priority
to tasks, but they do not have a stack and they cannot sleep.  In the
code, these are also referred to as @dfn{idle functions}, although that
term is slightly incorrect (they are guaranteed to be called even on a
fully busy system).

You can register a periodic function at various
rates: either every 16ms, 100ms, 1 second, or 10 seconds.  Handlers may not
be called at the exact rate, but it will be as close as possible.  Slippage
occurs when it takes longer than 16ms for all tasks to be given a chance to run.
If you need exact timing, use a realtime function.

For example, assume that a 1 second handler does not get called until
after 1.5 seconds from the previous call, because the system is busy running
other tasks.  Then the next time it will be called just 500ms
later; the scheduler will realize that it is behind and try to catch up.

You cannot dynamically register or deregister periodic handlers at runtime.

@subsection Task APIs

@table @code

@item task_create_gid

The basic API to create a new task.  You specify a code function and a GID.  The function
must reside in the same bank of ROM.  If the function is in a different ROM page, you
need to call @code{task_set_rom_page} @emph{immediately} after this call to say where
it was placed.

@item task_create_gid1

Similar, but checks to see if a task with the same GID already exists; if it does, no new
task is created.

@item task_recreate_gid

Similar, but checks to see if a task with the same GID already exists; if it does, the old
task is stopped before the new task is created.

@item task_sleep

Suspends the current running task for @emph{at least} the given period of time.  The parameter is one of the
@code{TIME} defines which is given in units of approximately 16ms.  Because it is 8-bit, this limits it
to about 4 seconds.

If you want to sleep for the absolute minimum, instead of @code{task_sleep (0)} it is recommended
to use @code{task_yield()}.

@item task_sleep_sec

Suspends the current running task for the given number of seconds.  This handles larger
timeouts, but does not allow the same granularity.

@item task_exit

Exit from the current task.  This must be called; task functions cannot just return when they
are done (that is guaranteed to cause a crash).

@item task_find_gid

Returns the first PID found for a task that has a given GID.

@item task_kill_pid

Stops another task based on PID.  This stops exactly one task.

@item task_kill_gid

Stops another task based on GID.  This can stop one or more tasks.  If called from a task with
the same GID, it stops all other tasks, but keeps the running task alive.

@item task_set_arg

The creator of a task can pass a single 16-bit value or pointer to it using this call.
It should be called before a task switch might occur.

@item task_get_arg

Called by the newly created task to obtain its argument.

@end table


@node Real-Time Processing
@section Real-Time Processing

The multitasking APIs are flexible but do not guarantee realtime response, since
any task may run for a long time.  Processing that needs to occur at a strict interval
is done by @dfn{real time tasks}, sometimes abbreviated in the code as @dfn{RTTs}.

Optimizing the realtime tasks is key to an efficient system.  To date,
about 35-40% of the 6809 is spent in realtime tasks; the actual value
depends on the machine and the number of device drivers needed.

@subsection Overview
@cindex Real time tasks

Real-time tasks are scheduled at @emph{compile-time}.  When you write an RTT, you
must also add an entry to the @dfn{schedule file}, either @file{kernel/system.sched}
for the core parts of the system, or @file{machine/@var{machine}/@var{machine}.sched}
for the game-specific RTTs.  Each entry in the schedule file gives the rate at which
you want your function to be run, for example, once every 8ms.  You can schedule
to run as frequently as once every 1ms, but you should only schedule as often as
you really need it, otherwise the CPU will have little time to do anything else!

Real-time functions run in interrupt context.  The periodic interrupt will preempt anything
else that is running at non-real-time priority.  Realtime functions cannot sleep.

A scheduler, @command{gensched}, processes the schedule files at compile-time and generates
the interrupt handler code which calls all of the RTTs at the correct frequency.  The output
can be seen in @file{build/sched_irq.c}.

@subsection Schedule File Syntax
@cindex Schedule files

Each line in the schedule file is formatted as follows:

@var{function} @var{frequency} @var{duration}

@var{function} identifies the name of the function that you want called in realtime
context.  If you prefix the name with an exclamation point '!', the function is assumed
to be an inline function; otherwise, it is an ordinary function.  You can append a
conditional as a suffix, e.g. @command{my_rtt?CONFIG_FOO} will call @command{my_rtt},
but only if the conditional @command{CONFIG_FOO} is set.

@var{frequency} says how often the function should be called, in multiples of the
system IRQ tick, which is 1ms on WPC.  Presently, this value can range from 1 to 2048 ms.
It must also be a power of 2.

@var{duration} says how long this function takes to run, in the worst case.  The
scheduler tries to reserve enough CPU cycles for all RTTs and to arrange the order in
which they are called so that tasks are balanced.  The duration is also given in milliseconds
and should be less than 1ms.  It can also be specified in CPU cycles by appending the 'c'
suffix.  It is not critical if the value is not exact, but a reasonable approximation
should be listed.

Blank lines and lines beginning with the '#' sign are treated as comments.

@subsection Function Unrolling

By default, the scheduler will unroll the interrupt handler into 8 smaller handlers.
That is, over a period of 8ms, the system will cycle through 8 different interrupt
handlers.  The reason is that this cuts down on the number of checks which have to
be performed on every IRQ, since infrequent (greater than 8ms) actions do not need
to be tested every time.

If a function is scheduled every 4ms, then it will be called from half of those
interrupt handlers (every other one, either the even-numbered ones or the odd-
numbered ones).  Likewise for functions scheduled every 2ms.  Functions scheduled
every 1ms are called every time.  For functions scheduled 8ms or more, those are
all executed from the last of the 8 handlers, and 'if' statements wrap the blocks
of code that need to run less often.

Sometimes you may want to unroll a function manually.  An example of where this is
used is with the switch detection logic.  All switches must be polled every 2ms.
However, it takes a long time to poll every switch.  Instead, we poll half of
the switches during 1ms, and the other half on the next 1ms.  This spreads out the
processing and keeps the length of any one IRQ call from being too long.

To tell the scheduler to do this, first write two separate rtt functions.  By
convention these are numbered with a suffix, e.g. switch_rtt_0 and switch_rtt_1.
Then in the schedule file:

switch_rtt/2   1   280c

The "/2" says that the function was manually unrolled into two separate RTTs.
The frequency is now 1ms, because one or the other will be scheduled twice as often
now.  The duration is the length of time it takes for one of them to run, and is
currently assumed to be the same for both.

@node Memory Allocation
@section Memory Allocation

FreeWPC does not use dynamic (heap) memory allocation, except in some very
rare circumstances.  All variables should be declared global, or put on the stack.

Global variables cannot be statically initialized.  Variables should be initialized
explicitly inside a C function.

Global variables can be divided into a number of categories, depending on their
usage.  Normal globals are always in scope and behave as you would expect.  Additionally,
you can tag a global with one of the following attributes:

@table @code

@item __fastram__

Used for variables that are used frequently.  GCC6809 will generate faster
code when accessing these.  However, you are limited to about 250 bytes of
fastram variables total.  These are mostly used by RTTs for performance.

Do not use fastram unless you are working in the core system, or writing
a device driver that runs more than once every 4ms or so.

The performance gain is just 1 CPU cycle faster and 1 fewer byte of code
per read or write access.


@item __permanent__
@cindex Permanent variables

Used for variables that should be persistent across reboots.  These variables
should be initialized inside of a @code{factory_reset} event, because factory
reset should restore everything to a sane state.  GCC6809 places these variables
at an address that is not automatically cleaned by the startup code during the
memory test.

The @code{init} or @code{init_complete} handlers should test these values for
sanity, since they may become corrupted due to software bugs.  If this is
detected, they should be restored to sane values for non-fatal cases if possible,
otherwise a factory reset should be forced.

@item __nvram__
@cindex Non-volatile variables

Like __permanent__, but for variables that are also write-protected by default.
To modify such a variable, you must first call @code{pinio_nvram_unlock()}, change
it, and then call @code{pinio_nvram_lock()}.  This helps to ensure that
certain critical variables are not accidentally corrupted.

Do not sleep while inside the critical section.  Do not nest calls to these
functions either.

This feature makes use of special hardware in the WPC ASIC.

Adjustments and audits kept in NVRAM are managed via special APIs which
do the locking/unlocking for you.

This feature works even in native mode; the __nvram__ variables are saved
to a file when you exit the program.

@item __local__
@cindex Per-player variables

Used for variables that are maintained separately for different players
in a multiplayer game.  The system software will transparently reload
these variables with the correct values whenever the player up changes.
These variables should be initialized inside of a @code{start_player} event.

There is a limit to how many locals can be declared; if you exceed this, you
will get a linker error.

@end table

@node Bit Variables
@section Bit Variables

Although ordinary variables work well, sometimes you only need
to store a single bit.  For this, instead of declaring a byte
variable and wasting 7 of the 8 bits, you can use a @dfn{flag}.
Flags are packed efficiently in the memory to avoid wasting
space.  This can be used helpful on small memory platforms.

The bit APIs are the most generic.  You provide a bit number
and a pointer to a bit buffer where the bits are packed.

The flag APIs operate on a per-player flag buffer.  They are
also automatically cleared at player start.  You only provide
a flag number.

The global flag APIs are similar, but those flags are global and do
not change across players, nor across games.

Flag and global flag IDs are distinct.  Be careful not to pass
a global flag ID to a flag API, or vice-versa.

@table @code
@item bit_on, flag_on, global_flag_on
Sets a bit flag.
@item bit_off, flag_off, global_flag_off
Clears a bit flag.
@item bit_toggle, flag_toggle, global_flag_toggle
Toggles a bit flag.
@item bit_test, flag_test, global_flag_test
Tests a bit flag.
@end table


@node Event Handling
@section Event Handling
@cindex Callsets
@cindex Events

FreeWPC is mostly an @dfn{event-driven} system, which only acts when there are new
inputs to the system.  This section describes the basic interface to the
application layer software, and then explains how that is implemented internally.

When any module wants to be notified when a particular event occurs, it declares
an event catcher function, using the CALLSET_ENTRY macro.  Here is an example:

@example
CALLSET_ENTRY (strobe_multiball, sw_forcefield_target)
@{
	...
@}
@end example

This declares a new catcher for the module named @code{strobe_multiball},
which is to be called whenever the event @code{sw_forcefield_target} occurs.

The name of the module is arbitrary, but the convention is to use the name
of the source code file or something similar.  If you need to write two different
handlers in the same source file for the same event, they need to have different
module names.

The event name must exactly match the name used by the generator of that event.
There is a list of predefined system events which are often caught (@pxref{System Events}).
Switch names can also be used as events (e.g. sw_free_kick_target).  Normally a switch
event is generated on an @emph{inactive-to-active transition}; you can cause an event
on any transition by declaring the switch as @samp{edge} in the machine configuration file.
Ball devices also generate events for several reasons (@pxref{Ball Tracking}), for example,
@code{dev_lock_enter}.

If there are multiple catchers for the same event, then all of them
will be invoked, in some random order.  For example, another mode might
also make use of the same target shown above:

@example
CALLSET_ENTRY (mode_start, sw_forcefield_target)
@{
	...
@}
@end example

Then both of these handlers would be called when the switch is closed.

To generate an event, use the @code{callset_invoke()} API, passing
it the name of the event.  You can create your own events for any
purpose; event names do not need to be declared.  Such events are
as full-featured as system-defined events.  When defining custom events
in a game, it is customary to prefix the event name with the short
name of the game (e.g. @samp{tz}).

Event catchers are allowed to throw new events.  This will result
in nested function calls.

@subsection Boolean Events

Most event handlers do not return a value.  However, in some cases
it is desirable to stop calling event handlers once the event has
been @emph{claimed}.  You can do this with boolean events.

To throw a boolean event, use @code{callset_invoke_boolean()}.  This
returns TRUE if all of the event handlers return TRUE; else it
returns FALSE.

The event handlers are declared using @code{CALLSET_BOOL_ENTRY} instead
of @code{CALLSET_ENTRY}, and they must return either TRUE or FALSE.

The invocation of boolean handlers will immediately stop if one of them
returns FALSE (so-called @dfn{short-circuit evaluation}).

@subsection Debugging Event Handlers

The runtime code generated by @command{gencallset} will call the macro @code{callset_debug}
before invoking each of the handlers.  This macro is passed one argument, which is a 16-bit
integer that is unique to every handler.  The default implementation is to save this in
persistent memory; if a crash occurs, after rebooting the value can be examined to help
determine the last function that caused the problem.

Previously, debugging required a compile-time flag set in @command{CALLSET_FLAGS}, but this
is no longer needed.

For more thorough debugging, you can rewrite the implementation of @code{callset_debug}
to do something else with those IDs, such as print them or set a breakpoint.

@subsection How Event Handlers Are Implemented

When you write a @code{CALLSET_ENTRY}, the module name and event name are
concatenated to form the name of a function, separated by an underscore.

When you write a @code{callset_invoke}, it calls a function named @code{callset_@var{event}}.
@command{gencallset} scans all of the source code and creates these functions; you can
see the output in @file{build/callset.c}.  So there is no queueing, memory allocation, or
anything complicated --- these are just ordinary function calls.  The trick is to do all
of the work at compile-time.

Because event handlers are just function calls, they can sometimes become deeply
nested.  For example, a start button press can cause many other events to be
thrown.  On the 6809 hardware, the stack size is limited and a stack overflow can
occur if functions nest too deeply, AND a call to @code{task_sleep} is made.  As long
as you don't sleep, there is no problem; the limitation is in the size of the per-task
stack area.  @code{start_game} and @code{test_start} are particularly problematic
sometimes.  Avoid sleeping in such handlers to be safe; if necessary, use a periodic
function instead.

@node Template Drivers
@section Template Drivers
@cindex Templates

A @dfn{template} is a crude implementation of a reusable code block, similar in
purpose to C++ templates but much more limited.  Were FreeWPC written in C++,
regular templates would have been used here.

Templates end in @file{.ct} (for C template) and are always kept in the
@file{drivers/} directory.  A template file is @dfn{instantiated} via
commands in the machine description.  The script @command{ctemp} converts
a template to one or more .c or .h files, which are then compiled normally.
Thus, templates can contain RTTs or event handlers just like any other file.

@subsection Template Syntax

A template contains ordinary C code, plus special @dfn{template directives}.
These always begin with two at-signs (@@@@).  The list of valid directives,
in the order that they are normally used, is listed below:

@table @code

@item @@@@class

Gives the name of the template; usually this is related to the filename.

@item @@@@parameter @var{name}

Declares a template parameter.  The value is substituted during instantiation.

@item @@@@file

Sets the current output filename.
A template can generate any number of output files.
You can switch between the different output files with this directive.

@item @@@@

A template comment.  Used to insert a comment line that is not placed
into the current output file.  Ordinary C-like (or shell) comments will be
emitted into the output files like any other non-directive line.

@end table

Within the C code, you use single-at (@@) references to substitute the
values of template variables into the text.  For example,

@example
@@@@class xyz
int @@class_variable
@end example

would be translated into the following plain C code:

@example
int xyz_variable
@end example

Notice that template variable names cannot contain underscores.

You define your own template variables with the @@@@parameter directive.
Some variables are predefined by the code generator:

@table @code

@item @@class

The name of the template, as given in a @@@@class directive.

@item @@self

The name of the instance.  If a template is instantiated multiple times,
each should have a different name.  For example, the @samp{sling} class
might have instances named @samp{left_sling} and @samp{right_sling}.

@item @@instance

Like @@self, but a zero-based ID.  These are assigned by the code
generator during instantiation.

@end table

Variable substitutions can occur just about anywhere.  For example, you
can use a variable as the argument to the @@@@file directive.  In fact,
this is generally how you would use it.  Consider the following:

@example
@@@@class widget
@@@@file @@class.h
@@@@file @@self.h
@@@@file @@class.c
@@@@file @@self.c
@end example

Here, the template named @code{widget} is defined.  It generates four
different source files: two based on the name of the class (@file{widget.c}
and @file{widget.h}), and two based on the name of each instance.
If there were 2 widgets instantiated by the machine, say a left widget and
a right widget, then we would have @file{left_widget.c}, @file{left_widget.h},
@file{right_widget.c}, and @file{right_widget.h}.

@subsection Template Usage

The use case for templates is to define reusable device drivers.  From game
to game, there is commonality on how certain devices should be treated,
although the parameters are different.

Typically, a device requires a number of different functions to control it.
Most devices need a realtime function if hardware accesses must be
frequent.  A periodic function can handle less critical actions.
APIs are defined for the rest of the logic to access it.  All of this
can be put into a single template, then instantiated by each machine with
values for the machine-specific parameters.

Currently there are device drivers for all of the following:

@itemize @bullet

@item Special Solenoids (@code{spsol.ct})
@cindex Special solenoids
@cindex Slingshots
@cindex Jet bumpers
@cindex Pop bumpers
@cindex Kickbacks

These are switch-activated coils, like slingshots, jet bumpers, or
kickbacks.  When the switch activates, the associated coil is fired.
The driver allows you to enable/disable the automatic action, as well
as defining the length of the coil pulse.  The switch is also briefly
ignored afterwards to prevent rapid-fire action.

@item Spinners (@code{spinner.ct})
@cindex Spinners

The driver is useful because it handles the fact that spinner switches
activate very fast.  It polls the spinner switch at a fast rate and
keeps a count of the number of activations, which are then processing
by a slower callback at normal task time.

@item Duty-Cycled Coils (@code{duty.ct})

This is typically for a diverter that needs to be held on for a long
period of time, like TZ's left ramp.  Enabling the coil begins by
applying a high power pulse, then dropping to a lower power duty cycle
(typically 25% but it is configurable.)  It is emulating what the
Fliptronic flippers do with a power and hold coil, except that there is
only one physical coil.

@item Bidirectional Motors (@code{bivar.ct})

Used by the Twilight Zone clock and the World Cup Soccer ball.
For when there are two inputs to the motor to control direction.

@item Drop Targets (@code{drop.ct})
@cindex Drop targets

A generic, single drop target driver.  Handles software knockdown when
capable, and retry functions.

@end itemize

@node Fault Detection
@section Fault Detection
@cindex Fault detection

Fatal errors when detected will cause the system to reboot.  The system
API @code{fatal()} can be used to cause a fatal error at any time.
A list of the error codes is kept in @file{include/sys/errno.h}.

There is also the @code{nonfatal()} API
for logging errors which will not cause a reset.  These are audited
and when @code{DEBUGGER} is defined, it will display a brief message on the DMD.

The core operating system code throws fatal errors in several key
circumstances:

@itemize @bullet

@item When task scheduling locks up

Because tasks continue to run until they give up control, a "hung" task
will hang the entire system.  At realtime level, this can be detected
by seeing that the current task has not changed for a certain period of
time.  This works because realtime uses interrupts.

@item When we cannot create a new task

The number of tasks is bounded, to prevent runaway task creation/
memory allocation.  Many other subsystems do the same whenever a limit
is reached.

As a result, you never need to check the return value of a @code{task_create}
call, because if it fails, then control is never returned to you.

@item When an NMI or other unexpected interrupt occurs

@item When the non-volatile memory is found unlocked.

This is almost
always because someone called @code{pinio_nvram_unlock()} and forgot
to call @code{pinio_nvram_lock()} afterwards, or executed a @code{task_sleep}
in between.

@item Certain illegal function calls are made, such as trying to sleep
from outside task context.

@end itemize

@node Timers
@section Timers
@cindex Timers

There are a number of ways to implement timers.  There are slight
differences between them all.

@subsection Task Timers

The first way is just to use @code{task_sleep} from within task context.
A task can sleep in between actions to enforce a particular delay.
Note that this gives a @emph{minimum} delay; the actual delay may be longer.

If you are not in a task context that can sleep, you can create a new
task which is allowed to sleep.  Starting and stopping such tasks is
equivalent to starting and stopping a timer.  Querying the task by its
GID is equivalent to checking if the timer is still running.

If you want to use this model, consider using the @code{timer_@var{xxx}} APIs,
which do this underneath a standard API that clearly shows what you are trying
to accomplish.

Because these timers are based on tasks, they do not need to be statically
declared in advance.  They are limited in number only by the maximum number of
tasks.

@subsection Free Timers

Sometimes you may want a timer, but without the overhead of a separate task.
Then use the @code{free_timer_@var{xxx}} functions.  @dfn{Free timers}
are small counters that are updated in realtime context.  They do not
support pausing (hence, the name) but can be started/stopped.  The set
of all free timers must be declared in advance in the machine
configuration file.

Free timers are useful for the case when you need to run a timer, and
no code needs to be executed when the timer expires.  You can always
write code to query the timer value, but if it expires to zero, then
nothing special happens.  One common use is for detecting certain
playfield shots when a series of switches needs to activate within
a certain amount of time, say 1 second apart.

@subsection Periodic Functions

@subsection Realtime Functions

@node Bank Switching
@section Bank Switching
@cindex Bank switching
@cindex ROM banks
@cindex Paging
@cindex ROM paging

The 6809 processor does not allow all of the ROM image to be accessible at once.
32KB of the ROM (the uppermost portion) is fixed and can be accessed at all times.
The remaining ROM is divided into "banks" or "pages" of 16KB each.  Access to
these areas is a little more complicated.

You can use the @code{page_push} and @code{page_pop} functions to change the
current banked area.  You must only call these from code running in the fixed
area, otherwise the current function becomes inaccessible!  Many kernel functions
use these to retrieve data that is placed into specific, named banks (e.g.
fonts and DMD transition functions).

The GCC6809 compiler supports function calls across all of the banks without
much effort from the programmer.  Each C file that is compiled must have all
of its code and constant data placed into the same bank.  You specify which
bank via the Makefiles.  For example, suppose you add a new file to the
common directory, named newfile.c.  In common/Makefile, the line:

@code{COMMON_BASIC_OBJS += common/newfile.o}

adds this module into the COMMON_OBJS list; all of these objects are part of
the COMMON_PAGE bank.  In the top-level Makefile, you can see that
COMMON_PAGE is mapped to bank 56.

There are a number of predefined sections, like COMMON, EFFECT, TEST, and TEST2.
More can be added by modifying the topmost Makefile.  Each of these is then
mapped to a physical bank of ROM; it is possible for multiple sections to map
to the same physical page.

The Makefiles only control the @emph{placement} of code and data.  To make function
calls between sections work correctly, you also need to modify the C prototypes.

When the compiler encounters an ordinary prototype, such as:

void foo (void);

then a call to @code{foo()} is an ordinary call with no consideration for banking.
However,

__attribute__((page ("56")) void foo (void);

says that @code{foo()} will be physically placed in page 56, and a far call might be
needed.  If the calling function is not in page 56, then the compiler will emit some
special code to switch the bank, make the call, and restore the bank.  This even
works when the caller is in a different bank and not in the fixed region.  When
each file is compiled, it is told which page it is in using the -mfar-code-page option.

Because this mechanism is used so often, there are macros to make it easier.
The above prototype could be rewritten as:

__common__ void foo (void);

See @file{include/env.h} for a list of the macros that can be used.  In general,
every section has an attribute that can be used like this.

Because placement is a somewhat manual procedure, it is possible for a bank to
become full.  When that happens, code often must be moved or new sections added.
This is rare but does happen from time to time.


@c ======================================================
@node Core APIs
@chapter Core APIs

The core APIs provide a common set of hardware access functions
that can be used by game designers.  The interfaces are designed to be
portable to all pinball hardware platforms and all machines.
However, the underlying implementation may vary.

These functions do not access the hardware directly, but instead, they
call into a device driver which may be platform-specific (@pxref{Platform APIs}).

These APIs are intended to be called from the application layer (what other
operating systems might refer to as "user space").
For example, there are core APIs to poll the state of switches (active, or
inactive?).  Under the hood, the switch driver must deal with the fact that
switches are arranged in rows and columns, and that some switches are optos:
this is all transparent to the user.

Core APIs are all defined in the @file{kernel} directory.  Any functions
which are not @code{static} may be called from game developers from within
normal task context at any time.

@menu
* Switches::              How to read switches
* Lamps::                 How to control the lamps
* Solenoids::             How to pulse solenoids and flashers
* Dot-Matrix Display (DMD):: How to draw to the dot matrix display
* Sound Board::           How to talk to the sound board
* General Illumination::  How to control the general illumination strings
* Real-Time Clock::       How to control the realtime clock
* Debug Port::            How to write to the debugger port
@end menu

@node Switches
@section Switches
@cindex Switches

Switches are present in all pinball games to receive input from the ball
and the player.

Switches are numbered from 0 to @code{NUM_SWITCHES}-1.
How the switch numbers are mapped to actual inputs is platform and
machine dependent.  The machine description names the switches and defines
their physical characteristics.

Each switch entry can declare the following
flags, which alter the way that the switching code will manage
it.  The capitalized name is used in the C code; the lowercase
name is the spelling used in the machine config file.

@itemize @code

@item SW_OPTICAL (opto)

Says that this is an optical switch, which is active low rather than
active high.

@item SW_EDGE (edge)

Says that the event handler (CALLSET_ENTRY) should be thrown in both directions:
when it becomes inactive or active.
Handlers for edge switches generally
need to check which type of transition just happened, by calling
@code{switch_poll_logical}, and then act accordingly.

All counting switches in a ball container must be edge switches, so that the
device count can be updated correctly.  The shooter switch is also usually
declared edge.

@item SW_IN_GAME (ingame)

Says that this switch should only be serviced during a game.

@item SW_PLAYFIELD

Says that this switch is on the playfield, and can be activated by a ball,
as opposed to cabinet buttons, motor optos, etc.  A playfield switch
event will normally set the valid playfield flag.  It will also cause the
@code{any_pf_switch} event to be thrown, which is normally used to score
during "frenzy" modes.  These switches also reset the ball search timer
to prevent a search from starting.

This is the default; use the @code{noplay} tag to indicate that a switch
is not playfield scoring.

@item SW_NOVALID (novalid)

Set for a SW_PLAYFIELD switch for which the valid playfield flag should
not automatically be set.  This is used for switches that might
unreasonably activate not due to a ball, such as a misaligned jet bumper
that continually fires.

These are the switches that you can trigger at ball start and drain, and
still get the ball back.

@item SW_IN_TEST (intest)

Says that this switch handler should also be called in test mode.
Normally in test mode handlers are not called, but important switches
like cabinet buttons require this.  If this flag is set, handlers will
need to test the @code{in_test} variable to see if we are in test mode,
and act accordingly.

@end itemize

In addition to polling their levels, the switch driver will detect
when switches have @emph{changed state}, and invoke their event handlers.
The switch entry in the config file names a function to be called when
these changes occur.

The driver performs debouncing, so that rapid open and close
are not considered.  By default, a switch is processed if it remains
active for only 4ms.  You can declare a larger debounce time using the
@code{debounce} tag.  A transition that lasts for less time is ignored.

Switch entries can also declare an associated playfield lamp; when
this is done, valid activations of the switch will cause a brief
flicker of the lamp.

@table @code

@item switch_poll

Read the stable, physical state of a switch.  Returns 1 if it has
a high level, or 0 for a low level.

Switch readings are polled by the switch driver continuously; this
API just returns the results of the last time the switch was
examined.  How often switches are polled is platform-dependent;
on WPC, it is every 2ms.

@item switch_poll_logical

Read the stable, logical state of a switch.  Returns 1 if it is
active, or 0 for inactive.  This is the same as @code{switch_poll}
but it inverts its result for optos.

@item rt_switch_poll

Like @code{switch_poll}, but only for use inside realtime tasks.
It is slightly more efficient.  It always returns a physical level;
drivers must invert for optos.

@end table

@node Lamps
@section Lamps
@cindex Lamps

Controlled lamps are used to highlight shots on the playfield and to keep
track of the progress of scoring features.  Unlike general illumination,
each lamp is individually controllable by the CPU.

Lamps are numbered from 0 to @code{NUM_LAMPS}-1.  For each lamp, there
are several flags that can be set to determine its physical state.
The job of the lamp driver is to combine all of these flags into a
single output value, and send that to the underlying hardware.

Every lamp has a @dfn{basic state}, which is either @emph{on},
@emph{off}, or @emph{flashing}.  The basic state of a lamp is
a per-player value and is automatically saved and restored as players
change in a multiplayer game.  It is managed by the following APIs:

@table @code
@item lamp_on
Turns on a lamp.
@item lamp_off
Turns off a lamp.
@item lamp_test
Tests whether a lamp is on/off.
@item lamp_toggle
Toggles a lamp's on/off state.
@item lamp_flash_on
Enable lamp flashing.  Note that the steady state of a lamp must be
off in order for the flashing to be seen.  (I.e., if you call lamp_on(),
and then lamp_flash_on(), the lamp will be @emph{steady}.)
@item lamp_flash_off
Disable lamp flashing.
@item lamp_flash_toggle
Toggle lamp flashing.
@item lamp_tristate_on
Ensure the lamp is steady.
@item lamp_tristate_off
Ensure the lamp is off.
@item lamp_tristate_flash
Ensure the lamp is flashing.
@end table

The basic state may be temporarily overriden via a @dfn{lamp effect}.
An effect can allocate a lamp, thereby overriding its basic value.
When the effect finishes, it frees the lamp, causing the basic state to
be shown again (@pxref{Lamp Effects}).

In the machine description, you can attach a color and coordinates
to each lamp.  These are not used by the core OS, but they can be used
to construct nice looking lamp effects that manipulate them in certain patterns.

@node Solenoids
@section Solenoids
@cindex Solenoids

Solenoid outputs are used for many purposes.  We use the term 'solenoid'
or 'coil' generically to refer to any writable, high power output.
They could be connected to coils, flashers, or motors.
Like the lamps, they are individually controllable.

Unlike the controlled lamps, the core API does not permit you to turn on
a solenoid permanently.  Instead, you either use a pulsing API, which
turns it on for a short period of time (and the system turns it back off
for you), or you use a custom driver to control it.

@subsection Pulsing
@cindex Pulsing solenoids

@dfn{Pulsing} is used for solenoids that are operated infrequently,
and only for short durations at a time.
These are normally used for kickers, poppers, etc.
The system queues the requests and executes them one at a time, never
in parallel.

The default pulse settings are controlled by the entry
in the machine description, in the "drives" section.  The @code{time}
parameter sets the total length of time for the pulse.  It can be an integer
value in milliseconds, or one of the @code{TIME_xxx} values which are in
multiples of 16ms.  The @code{duty}
parameter controls the duty cycle; use one of the @code{SOL_DUTY_xxx} defines.
SOL_DUTY_100 keeps the driver on for the entire interval; SOL_DUTY_50 keeps
it on half the time, delivering half the power; and so on.  The minimum duty
cycle is 1/8th full power.

If you do not specify either of these values, you will get a reasonable, but
conservative default.  Solenoids and flashers may have different default values.
A large portion of getting a new game to work correctly is determining the
correct values to use here.

@table @code

@item sol_request

Pulse a solenoid, and wait for it to be fired.  A request may
be delayed for a number of reasons.  This should only be used inside
of a task context where it is acceptable that the call may block for
a while.

@item sol_request_async

Pulse a solenoid, but don't wait for it to be fired.  This is the preferred
method to use.  This function returns immediately, before the pulse
occurs.

@item sol_req_start_specific

This is the most flexible API, which allows you to specify the exact duty
and time parameters that you want, overriding the defaults from the machine
config.  It is not recommended for ordinary use.  It is exposed by test mode
to allow you to try different settings to see how they behave.

@end table

@subsection Flashers
@cindex Flashers

The flashlamp APIs are similar to the solenoid pulse APIs.
A flashlamp pulse is always with a 100% duty cycle, but for a much shorter
period of time.

Note: it is currently possible to use the solenoid pulse APIs on flashers,
but this should not be done.  This will likely be enforced in the future.

@table @code

@item flasher_pulse

Pulse a flashlamp for a nominal period of time.

@item flasher_pulse_short

Pulse a flashlamp very quickly.

@item flasher_start

This is a lower-layer API that allows you to specify the exact duration
and duty cycle for a flasher.  Times longer than FLASHER_TIME_DEFAULT are
not recommended.  The duty cycle can be specified using one of the SOL_DUTY_xxx
defines to pulse it more dimly than usual.

@end table

@subsection Custom Drivers

@dfn{Custom drivers} can run for longer periods of time.
They are allowed to run in parallel with anything else.  They
will frequently use @dfn{duty cycling} to avoid keeping the
coil 100% active for too long, and thus they often require
realtime processing to switch reliably.

These types of drivers are all implemented using templates.

@c include coil-drivers.txt

@node Dot-Matrix Display (DMD)
@section Dot-Matrix Display (DMD)

Dot matrix APIs should only be called from display effects.

There are two key objects you should understand: pages and windows.

A @dfn{display page} is special RAM which holds the frame buffer that determines
which pixels are turned on and off.  Display memory cannot be accessed like
ordinary memory, though; it does not have a fixed address.

A @dfn{display window} is an address that the CPU can use to read/write display
memory -- that is, it sees one of the display pages.

There can be more display pages than windows, so not all pages are accessible
at all times.  Through @dfn{mapping calls}, you decide which pages are mapped
to which windows.

You must go through several steps for each frame you want to write.  For
each step, there are several APIs to choose from.

@itemize @bullet

@item Allocate a new display page.
The new page may contain old, stale data in it; it is not necessarily initialized.
Allocation alone does not make it accessible, only reserved.

@table @code
@item dmd_alloc_@var{map}
Allocate and map a single page into either the low or high area.

@item dmd_alloc_low_high
Allocate and map two pages at once.  The pages will always have consecutive
page numbers (N and N+1).

Do not assume that the low and high windows are contiguous in memory.

@item dmd_dup_mapped
Allocate and map a page pair that is copy of what is currently mapped.

@end table

@item Map the page into one of the display windows.
FreeWPC requires at least two windows; some platforms support more.  These two
windows are called the @dfn{low window} and @dfn{high window}; the pages
that are mapped there are the @dfn{low page} and the @dfn{high page}.
The simplest effects can be be done using only the low page.  If you need color,
or flashing effects, you will probably need both the low and high page.
In the API names below, the term @var{map} refers to either @emph{low} or @emph{high}.

@table @code
@end table

@item Initialize the page if necessary.
If you are writing text only, you would want to clear the page first.  If you
are filling the page with a full-size image, that is not necessary.

@table @code
@item dmd_clean_page_@var{map}
Zero a display page.

@item dmd_copy_page
Copy an entire page from one buffer to another.
@end table

@item Render text and graphics on the page.  Text APIs implicitly write to the
low page only.  Graphics APIs generally write to the low page if dealing with
only 1 color, or to both low and high pages if multiple colors are used.
If you need to write to the high page, use @code{dmd_flip_low_high} to swap
them temporarily.

@table @code
@item font_render_string
Write text in the given font, starting at a specific coordinate.
@item font_render_string_center
Write text in the given font, centered about the given coordinate.
@item font_render_string_right
Write text in the given font, right-justified against the specified coordinate.
@item bmp_draw
Draw an arbitrary sized bitmap onto the low page.
@item frame_draw
Draw a full-size, 4-color frame onto the low and high pages.
@item dmd_text_outline
Generate a text outline page.  On input, the low page should contain nothing but text.
The high page should be allocated, but need not be clean.  On output,
the high page will contain an outline mask.

This API should be used when rendering text onto a color image.  Each '1' bit
in the mask corresponds to a pixel that should be made black in the final image,
so that the text stands out from the background image.  See @code{dmd_overlay_outline}
below for a method to do this.
@end table

@item Optionally, create a composite of several pages together
For example, overlaying text onto background art.  You can use @dfn{overlay pages},
which are additional fixed buffers that do not need to be allocated.  You can
use compositing APIs to join multiple pages together in different ways.

@table @code
@item dmd_overlay
Overlay ("or") the low overlay page onto the allocated low page.  Use when both
the allocation and the overlay are mono.
@item dmd_overlay_color
Overlay both low/high overlay pages onto the allocated low/high pages.  Use when
both the allocation and the overlay are 4-color.
@item dmd_overlay_onto_color
A hybrid of the above two APIs, used when the allocation is in color, but the
overlay is mono.
@item dmd_overlay_outline
Overlays text onto a color image.  The allocated low/high pages contain the image.
The low overlay page contains the text.  The high overlay page contains the outline mask,
created with @code{dmd_text_outline}.

This is a fairly slow call, as it is requires several AND and OR operations.
@item dmd_and_page
A low-level function to AND the contents of the low page, using the high page as a mask.
@item dmd_or_page
A low-level function to OR into the contents of the low page, using data from the high page.
@item dmd_xor_page
A low-level function to XOR the contents of the low page with the data in the high page.
@end table

@item Show the page.
Until the page is shown, it is not visible.  This prevents each step of the
rendering process from being seen, which is not visually appealing.  Once
the page is shown, it is implicitly freed back to the system, meaning that any
new changes to the display require allocating a new page again.  The page does
not need to remain mapped into a window for it to be visible.

@table @code
@item dmd_show_@var{map}
Show a single display page as a 1-color image.  It can be in either window.
@item dmd_show_other
If the low page is currently visible, then show the high page; and vice versa.
@item dmd_show2
Show both display pages together as a 4-color (3 plus black) image.
@end table

Prior to showing the image, you can schedule a @dfn{transition}.  You call
@code{dmd_sched_transition} just before showing to say which transition should
be used.

@end itemize

Other APIs are listed below.

@table @code
@item dmd_flip_low_high
Flip the mappings, so that the low page appears in the high region, and vice
versa.
@item dmd_rough_copy
@item dmd_rough_erase
Erase a rough region of the low page.  The x coordinates must be 8-bit aligned.
@end table

@node Sound Board
@section Sound Board

At present, sound support is very WPC-specific.  The sound board is an
external device that is controlled by sending commands over a serial-like
interface.  Two flavors of sound board are supported: WPC, and DCS.
The same APIs are used in either case.

@table @code
@item sound_send
Sends a command to the sound board.  The command may be 8-bit or 16-bit.
The meaning of the command argument varies widely.
@end table

@pxref{Sound and Music Effects} for other APIs that can be used.


@node General Illumination
@section General Illumination
@cindex General illumination (G.I.)
@cindex Triacs
@cindex Lamp dimming

General illumination allows for additional lighting that is managed in
groups of lamps, which are all enabled and disabled at the same time.
These are often referred to as GI "strings".
FreeWPC supports a maximum of 8 strings.

On the WPC platform, GI can be dimmed, because the controls for these
strings are governed through triacs.  (On WPC-95, some of the GI are
dimmable and some are not.)

@table @code

@item gi_enable

Turns on one or more GI strings.  The argument given is a bitmask where
each bit corresponds to an entire set of lamps (thus, we support at most
8 strings).

@item gi_disable

Turns off one or more GI strings.

@item gi_dim

Dims one or more GI strings.  This is like @code{gi_enable}, but it takes
an extra parameter, which specifies the @emph{intensity} of the lamps.
Not all hardware supports dimming.
If dimming is not supported, then this API is unavailable and
will cause a compiler error.

@end table

@node Real-Time Clock
@section Real-Time Clock
@cindex Clock time
@cindex Real time clock

On machines with a realtime clock, these APIs let you set and get
the current time of day.  At present, only WPC is supported.

The WPC ASIC provides three registers for counting minutes, hours, and days.
FreeWPC keeps the calendar time in persistent memory.
About once per minute, it polls the RTC and updates the calendar time to reflect
any changes.  The battery provides power to the ASIC even when the game is off
so the real-time clock remains updated.

Game code does not need to call the following APIs.  The current date and time
can simply be read from memory.

@table @code
@item rtc_read

Update memory based on the current value of the RTC registers.

@item rtc_write

Update the RTC chip.

@end table

@node Debug Port
@section Debug Port

@c ======================================================
@node Effects
@chapter Effects
@cindex Effects
@cindex Choreography

Effect processing is a layer above the hardware which provides
controlled access to the lamps, display, flashers, and general
illumination.  It resolves contention when multiple tasks try to
access the same object at the same time through the use of
priorities.

The system manages three distinct types of effects: display, lamps, and
music.  They are fully independent of each other.  It is not possible
to request that all three types do something in sync with one another.
There are similarities between the way each type is handled, but all
three have fundamental differences.

Lamp effects manage the controlled lamps, plus the GI and flashers.

@menu
* Basic Effect Principles::    What all types of effects have in common
* Background Effects::         When an effect should always be running
* Display Effects::            Extra properties of display effects
* Lamp Effects::               Extra properties of lamps effects
* Sound and Music Effects::    Extra properties of sounds and music
* Lamplists::                  How to work with more than one lamp at a time
* DMD Transitions::            Wipes, fades, etc. on the display
* Background Refresh::         Periodic updates other than display/music.
@end menu

@node Basic Effect Principles
@section Basic Effect Principles

These principles apply to all types of effects.

At any time, there is at most 1 effect that is @emph{running} of each
type.  The
running effect is the one which has been @emph{started} with the
highest priority.  Priorities are simple integer values:
the higher the number, the more important the effect is.  A list
of predefined priority values is defined in @file{priority.h};
these files begin with @code{PRI} and have been carefully defined relative
to one another.  Use one of these values when possible.


It is possible for no effect to be running if none has been started.
In that case, the current priority is considered to be zero.  Actual
effects always have a priority that is non-zero.

The running effect is executed in a separate task context, except for
music, which is executed on a separate CPU.  The
currently running display effect always has the group ID
@code{GID_DEFF}; likewise @code{GID_LEFF} for the lamps.  Effects
that are started but not running do not have a task assigned to them,
and are simply marked as started in memory somehow.  Because they do
not have enough priority to run, there is nothing for them to do.

Effect tasks can be preempted, if a higher priority effect is started later.
In that case, the old task is killed, and a new task is started.  When
the task is killed, there is no guarantee as to what was doing
previously, and there is no opportunity for it to do cleanup on its
own.

Effect functions must be declared in the machine configuration file.  Each
entry names the function to be called to run the effect, along with its priority
and other optional properties.

The APIs and implementation for display/lamp effects are mostly the
same, but there are differences due to the following:

@itemize @bullet
@item The lamp matrix can be suballocated; the display can only be
allocated as a whole.
@item Some display effects are long-lived, while others are only
temporary.
@item Some display effects do not have high priority, but we should
retry to start it later if possible.
@end itemize

@node Background Effects
@section Background Effects

The display and music should always be doing something, even when
nothing really important is happening.  Thus, these effect modules
implement @dfn{background effects}, a way to determine what to do
in these circumstances.  Lamp effects do not support a background mode;
it is OK for no effect to be running, as the lamps have a default state
that shows through.

The strategy for handling background effects is as follows:  When
there is no explicitly started effect, an event is generated:
either @code{display_update} or @code{music_refresh}.  Any module that can
provide a background effect should implement these handlers.

The handler can decide which effect, if any, it wants to provide by
calling either @code{deff_start_bg} or @code{music_request}.  (If the
conditions are not correct, it can simply return without doing anything,
as with a mode that is not running.)  The handler request includes
the ID for the deff or music to be started, plus a priority value.  After all of the
event handlers have been invoked, the one with the highest priority
wins and will be started.

The common code provides many of the implementations to deal with the
usual cases.  For example, while a game is running, the default effect
is to show the game scores.  Default music codes can be defined for
different circumstances: normal game play, ball at plunger, during bonus.

Because handlers can use the values of other variables in the
determination (are we in game, for example?), the calculations need to
be redone periodically, in case the conditions change.  To force a refresh
of both the display and music,
call @code{effect_update_request}.  The update will take place within the next
100ms; the delay is intended to smooth out multiple such requests within
a short time, and the delay is not really noticeable.

When a foreground display or music effect exits, an update will take place
immediately.  In this case, if display update is needed, then music is not
updated, and vice-versa.

If an update is not requested, the display and music will still be refreshed
periodically by the system, about twice per second, as the conditions checked
within the handlers may have changed.  Because of this, @code{effect_update_request}
is really an optional call, and only forces the update to happen faster.

@node Display Effects
@section Display Effects
@cindex Display effects
@cindex Aborting display effects
@cindex Kickout locks

Display effects are defined in the @code{[deffs]} section of the machine
configuration file.  Both foreground and background deffs are defined here.
Each deff has an implementation function, a priority, and one or more of
the following properties:

@itemize @code

@item D_QUEUED

Says that if the effect cannot be started now, to queue it and keep
retrying.  This flag should be set on higher priority messages that
really ought to be seen by the player.

@item D_TIMEOUT

Only applies to D_QUEUED deffs.  Says that they should timeout
eventually if they cannot be started.

@item D_ABORTABLE

Says that pressing both flipper buttons will abort this effect.

@item D_PAUSE

Says that while this effect is running, ball kickouts are paused.
This flag is typically set on important instructions or on big
scoring effects to allow the player to pause and celebrate.

@item D_SCORE

Says that this is a score award effect; the value of the last switch
score is made available to the effect via the @code{score_deff_get()} API.

@item D_RESTARTABLE

Says that if the effect is started when it is already running, that
it will be restarted (normally, the second call would do nothing).
This should generally be set on D_SCORE effects at least.

@end itemize

@table @code

@item deff_start

Starts a foreground display effect.

@item deff_stop

Stops a foreground display effect.

@item deff_exit

Exits from the currently running display effect.

@item deff_nice

Change the priority of the currently running display effect.
If it drops below the priority of something else waiting, this will
cause it to be preempted.

@item deff_update

Update the background display effect.

@end table

@node Lamp Effects
@section Lamp Effects
@cindex Lamp effects
@cindex Light shows

Lamp effects are defined in the @code{[leffs]} section of the machine
configuration file.  Each lamp effect defines a function that executes
when the effect is running, plus it says which of the lamps, flashers,
and G.I. strings it is able to modify.  Attempts to modify unallocated
objects have no effect.

The objects allocated to a lamp effect are guaranteed to be turned off
when the function starts, and are restored to their previous states
when the function ends.

A lamp effect can also be declared as @dfn{shared}.  A shared leff can
run in parallel with the current running leff, and with other shared
leffs.  Shared leffs have a lower priority than normal leffs; the
effect can be masked.  Also, shared leffs run to completion and are
never preempted.

Shared leffs are usually for indicating low-priority game state
that requires constant updating, and where it is not appropriate to use
the default lamp state.
Normal leffs are intended for light shows.

Lamp effects cannot be aborted by the flippers like display effects.

If a normal leff cannot be started, it is forgotten and never queued, like
display effects can be.

@table @code

@item leff_start

Starts a lamp effect.

@item leff_stop

Stops a lamp effect.

@item leff_restart

Stops and then starts a lamp effect again.

@item leff_on, leff_off, leff_toggle, leff_test

Called from within a lamp effect, sets/gets the state of a single lamp
that has been allocated to it.

@item gi_leff_alloc, gi_leff_enable, gi_leff_disable, gi_leff_free

Called only from within lamps effects.  These modify GI strings
overriding their default settings.

@item leff_exit

Exits from the currently running lamp effect.

@end table

@node Sound and Music Effects
@section Sound and Music Effects

The main difference with sound and music is that the main CPU does not
implement the effect; they are generated by a separate board.  The main
CPU sends commands to the secondary board to request that a particular
sound be played.  Because of this, no running task is required for the
effect.  (Platforms other than WPC may differ in this regard.)

Sounds and music may also overlap, depending on the capabilities of the
sound board.  Each platform defines a set of independent @dfn{channels}.
When a sound needs to be played, you can specify a subset of channels that
it can be played on.  If one of them is free, the sound can be played.
The system tracks which channels are free or in use.

There is no easy way to know when the sound has finished playing.
The sound board is capable of sending
responses back to the CPU board, but this has not been explored
thoroughly yet.  For now, sound calls need to specify how long the
sound will take to complete, so that the channels can be deallocated.
Exact precision is not really necessary here, unless trying to string
together a sequence of speech calls.

The @dfn{music channel} is treated special, because it is the one used
for the running background track.  All other sounds are transient, whereas
the music plays in a constant loop.

Some sound effects need to preempt the background music, so that both
are not heard simultaneously.  When a sound effect allocates the music
channel, that kills the background music first; when the temporary sound
finishes, the background is automatically restarted.

@table @code

@item music_update

Request an update of the background music.

@item sound_start

Start a sound effect.  This operates at a layer above @code{sound_send},
which is the low-level API to send a command to the sound board.
This API handles priority, channel allocation, and tracks the duration
of effects.

@item sample_start

Start a sound sample call.

@item speech_start

Start a speech call.

@item music_effect_start

Start a music effect that preempts the background.

@item music_disable

Disable the background music.

@item music_enable

Reenable the background music.

@item music_timed_disable

Disable the background music for a given amount of time; it will be
reenabled automatically once the time expires.

@end table

@node Lamplists
@section Lamplists
@cindex Lamp lists

Typically, groups of lamps are often used for a similar purpose.
A lamplist is an ordered array of lamps that are often controlled together.
Each lamplist has a unique ID, and is internally represented by an array of
the lamp values, terminated by a special lamp code named @code{LAMP_END}.

The lamplist APIs provide convenience whenever many lamps need to be updated
at once.

@table @code

@item lamplist_index

Return the nth member of a lamplist.

@item lamplist_first_entry

Return the first lamp in a lamplist.

@item lamplist_last_entry

Return the last lamp in a lamplist.

@item lamplist_previous_entry

Return the entry before a given one.

@item lamplist_next_entry

Return the entry after a given one.

@item lamplist_apply

Apply a lamp operator to all members of a lamplist.  If a break is
encountered, a pause will occur.

@item lamplist_apply_nomacro

Apply a lamp operator to all members of a lamplist, ignoring breaks.

@item lamplist_test_all

Return true if all members pass a given boolean test.  The test operator
lets you apply different test conditions, for example, testing the
lamp's default state versus its flashing state.

@item lamplist_test_any

Return true if any member passes a given boolean test.

@item lamplist_apply_leff_alternating

Alternatively set and clear every member of a lamplist.  You can specify
whether the first lamp will be set or cleared.  This can only be used inside
lamp effects.

@item lamplist_step_increment

Turn off the lamp that is currently on, and turn on the next one.

@item lamplist_step_decrement

Turn off the lamp that is currently on, and turn on the previous one.

@item lamplist_build_increment

Turn on the first lamp in the list that is not on.

@item lamplist_build_decrement

Turn off the last lamp in the list that is on.

@item lamplist_rotate_next

Rotate the lamp states forward.

@item lamplist_rotate_previous

Rotate the lamp states backward.

@end table

@node DMD Transitions
@section DMD Transitions
@cindex Transitions

A @dfn{transition} is an interim effect that runs between the end of one display
effect and the beginning of another.  By default, a new effect will simply
kill the old one and overwrite it with a new image.

Transitions are scheduled -- a handler is installed that runs the next
time that a new image is shown.  Instead of showing the image right away,
the transition handler kicks in and displays some combination of
the present view and the new one.  When the transition finishes, the
display should consist entirely of the new image.

Currently, all DMD transitions are contained in @file{common/dmdtrans.c}
and segment transitions are in @file{kernel/segment.c}.

@node Background Refresh
@section Background Refresh

In addition to the display and music effect updates, there are a couple
of other things that need to be refreshed periodically.  The default
states of the lamps, outside of any running effect, sometimes need to
change depending on a complex combination of factors.

For example, consider a feature that needs to be disabled temporarily
during any multiball.  Instead of using the lamp bit to track whether
the feature is enabled, we should use a separate bit flag, and then
draw the lamp if the flag is set @emph{and} the feature is not masked
by a multiball.

The @code{lamp_update} event is generated periodically by the system
to give modules a chance to recalculate the states of the lamps.
Currently, it is generated about once per 500ms.  Code can request
a faster update by calling @code{effect_update_request} as before.

Likewise, sometimes solenoid-driven devices require a periodic update
as well.  Ball scoops that raise from the playfield, like the trap door
on Funhouse, can either be up or down, and the desired state depends on
a number of things.  A separate @code{device_update} event is thrown for
the purpose of updating these.  It works identically to the @code{lamp_update}
function; however, these events are generated more frequently, as they are
more important to be right in a timely manner.

Note that device update is disabled during ball search, so that search
handlers can complete control of the devices to try to find the missing
pinball.

@c ======================================================
@node Ball Tracking
@chapter Ball Tracking
@cindex Containers
@cindex Ball devices
@cindex Ball tracking

The ball tracking module manages the locations of all of the pinballs in
the machine.  It is implemented in @file{common/device.c} and uses
container declarations in the machine description.

A @dfn{device} is defined to be something which can hold and release pinballs.
(Earlier versions of the software used the term @emph{container}.)
A device is comprised of one or more switches which count the number of balls
in the device, plus a release solenoid that can be pulsed to force one
ball to be removed.

Ball troughs, kickouts, poppers, saucers, and locks are all just different
shapes that a device can take.  Some containers only hold one ball, while
others can hold many.

@menu
* Device Status::              What state is maintained per device
* Global Status::              What state is maintained for the whole machine
* Events::                     Which events are generated
* The Trough Device::          How the trough device is special
* Virtual Balls::              How to manipulate ball counts manually
@end menu

@node Device Status
@section Device Status

For each device, the ball tracker maintains the following state information:

@itemize @bullet
@item The maximum number of balls it can hold.  This is a constant that
depends on the number of counting switches in the device.
@item The current number of balls it contains
@item The previous number of balls it contained earlier
@item The desired number of balls that game logic wants it to have
@item Whether or not it is in the process of trying to release a ball
@end itemize

The @dfn{desired count} is crucial to understanding the module's behavior.
Whenever the device has more balls than desired, the ball tracker will initiate
one or more releases
to try to bring the count down to the desired number.  Otherwise, any balls
that enter the device are kept there; this is used to implement ball locks.

Software requests to kick a ball are @emph{always} done by manipulating the
desired count.  The device module has complete control over the actual
release solenoid.

The trough device is the only device which normally desires to keep any balls.
Playfield devices generally desire zero balls unless a lock has been enabled.

Device switches must be declared as @emph{edge} switches, which invoke the
event handler on both open and close transitions.  The tracker simply updates
the current count on either type of transition.

@node Global Status
@section Global Status

@cindex Missing balls
@cindex Balls missing
The ball tracker also maintains a count of the number of balls in play,
which is the total number of balls installed, minus the number of balls
that are seen in devices, minus the number of balls declared "missing".
Missing balls are flagged when a game is started but the balls are not
all seen.

@node Events
@section Events

The ball tracker also generates new per-device events.  The name of
the event includes the name of the device: for example,
@code{dev_trough_enter}.

The @dfn{enter} event is generated when the current count goes up by 1.
Game code should normally always register handlers for the enter events
rather than individual switches.  Note that a switch closure does not
always indicate enter: consider an eject that is trying to kick out
but the kicker is weak, so that the ball falls back in immediately.
Also, when a ball trough releases a ball, a whole series of switch
closures occur rapidly, but eventually it stabilizes.  The ball
tracker waits a little while after switch change before it begins
to take action.

When a release is necessary, the module first generates a @dfn{kick_request}
event.  This is a boolean event; handlers can return FALSE if the request
should be postponed for some reason.  In that case, the module will retry again
later.  Once the request is allowed, a @dfn{kick_attempt} event is generated
just before the solenoid is pulsed.  This is typically caught in order to play
a sound effect.  If the pulse fails, the attempt event may be thrown multiple
times.

The @dfn{kick_success} event is generated when the release is deemed successful:
when the device count goes down by 1.  The @dfn{kick_failure} event is instead
thrown when an attempts fails repeatedly and the device is abandoned.

@node The Trough Device
@section The Trough Device
@cindex Trough device

The trough device is special; every game must have one.  The system
completely handles the device events generated for the ball trough.

@cindex Live count
@cindex Balls in play
The function @code{device_add_live} is called whenever a new ball
is successfully served.  The @dfn{live count} of the machine is the
number of balls in play for the purposes of game code (i.e. not counting
missing pinballs or balls locked on the playfield from previous games).
The @code{single_ball_play} event is generated when the live count
is reduced to 1.  Multiball modes use
this to stop properly.  There is also a @code{ball_count_change} event
invoked on every change of the number of balls in play; some games use
this to update playfield multipliers.

Likewise, @code{device_remove_live} is called whenever a ball drains.
It ultimately is the one that generates the @code{end_ball} event
when all balls have drained.

Live count is not necessarily the actual number of balls in play.
If a missing pinball suddenly reappears, the live count is not increased.

@node Virtual Balls
@section Virtual Balls

The device system generally assumes that there is one ball-sensing
switch for every ball that might be in the device.  Thus, a 4-ball
trough needs 4 switches.  The tracker recounts balls periodically
and does this just by polling each switch to see if a ball is present
or not.

For some devices, this is not possible.  Consider the Twilight Zone
gumball machine, which can hold 3 or 4 balls but there are no
switches inside to verify this.  To handle this case, @dfn{virtual balls}
are supported.  This is a per-device counter that is completely software
controlled.  APIs exist to add/remove virtual balls that cannot be seen
by switches.  Machine-specific code must be written to manage this.

When a device driver knows for sure that a ball has entered the device,
it calls @code{device_add_virtual}.  The extra ball will be tracked and
counted even though there is no switch to see it anymore.  When virtual
balls are added, the device @code{enter} event is thrown as usual, as
if a physical ball had entered.

When it knows that a ball has exited the device, it calls
@code{device_remove_virtual}.  This decrements the virtual ball counter.
This behaves exactly like when a real ball is kicked out, so the
@code{kick_success} event is thrown and the live ball count goes up.

@c ======================================================
@node Test Mode
@chapter Test Mode

The FreeWPC test mode works similarly to the original WPC menu system.
However, there are extra options and a few important differences.
For testing core changes to FreeWPC, it is often more convenient to use
test mode than to play a game.

You can navigate the menus with the flipper buttons in addition to the
coin door buttons.  Use Start to enter, and double flip to exit.

When compiling with the @code{MACHINE_TEST_ONLY} option, the game
will boot directly into test mode, and there is no provision to start a game.

@section Adjustments

All of the @emph{standard adjustments} are supported.  There are also a few
new adjustments.

@dfn{Timed Game} allows you to switch between normal game play and a timed
game.  Machines can implement different rules for timed play or not.
They can also disable it entirely.

@dfn{Payment Type} configures whether the display asks you to insert
coins, bills, or swipe a card.

@section Audits

All of the @emph{standard audits} are supported.

Presently, audits are kept as 16-bit integers, so they max out at 65535.
This will probably change at some point.

@section Tests

The test menu contains roughly the same tests as in the actual WPC
games, with some differences.

The solenoid test lets you control the duration and duty cycle of
each coil pulse by using the flipper buttons.

The development menu contains a series of additional tests that are
probably only relevant to developers and not to end users.  Current
tests include:

@itemize @bullet
@item Trigger specific display/lamp effects
@item Browse lamplists
@item Examine the states of all multiball devices
@item Test the random number generator
@item Test display transition effects
@item Run a display effect stress test
@item Analyze task scheduler performance
@item Analyze interrupt handler performance
@item Test the presentation of scores in multi-player games
@item A memory editor that allows inspection/modification of any
memory address.
@end itemize

@subsection Font Test

Cycles through all of the available fonts.  Use the flipper buttons
to scroll through the alphabet.  The machine will try to display
as much as possible at once, depending on the font size.

@subsection Display Effect Test

Cycles through all display effects.  Press ENTER to activate a deff,
as if @code{deff_start} were called.  For long-running effects, press
ENTER again to stop it via @code{deff_stop}.

@subsection Lamp Effect Test

Cycles through all lamp effects.  Press ENTER to activate a leff,
as if @code{leff_start} were called.  Press ENTER again to stop it.

Remember that multiple lamp effects can be active simultaneously if
they are declared as shared and they do not overlap in the lamps that
they use.

@subsection Lamplist Test

Cycles through the lamplists.  The flipper buttons cycle through the
different ways that the lamplist can be controlled.  The default is
to turn on all of the lamps.  You can also strobe them, flash them, etc.

@subsection Ball Device Test

Cycles through each of the ball devices, telling you its current status
(how many balls it sees, kickouts pending, errors).  The flipper buttons
will scroll through a set of actions (empty, kick 1, etc.); press ENTER
to perform the action displayed.

This test also continuously shows the global device status, such as
how many total balls are detected and whether any balls are missing.

@subsection Random Test

Tests the random number generator.

@subsection Transition Test

Cycles through all of the dot-matrix or alphanumeric transition effects.

@subsection Frame Test

Cycles through all of the display frames.

@subsection Force Error Test

Entering this test forces a fatal error, which should restart the system.

@subsection Display Stress Test

Starts randomly starting and stopping display effects until exiting the test.

@subsection Symbol Test

Cycles through the symbol bitmap, a collection of arrows, boxes, etc.

@subsection Score Test

Advance through the various combinations of players per game and
player-up, to show how the score screen would look.

@subsection PIC Test

Displays vital data about the PIC.

@subsection Memory Editor

Lets you interactively scroll through the CPU's memory and alter values.

@c ======================================================
@node Common Pinball Library
@chapter Common Pinball Library

The files in the @file{common} directory provide a library of generic
pinball functions that can be reused from game to game.  Some of the more
important ones are described in detail in this chapter.

@section Coins and Pricing

FreeWPC implements a weak form of coin switch handling.  It is not
very robust and does not time the coins as it should.

If @code{FREE_ONLY} is defined, it will build a ROM that doesn't require
coins.

@section Extra Balls

This module tracks lit and collected extra balls.  Lit extra balls can
be easy (lit until end of game) or hard (lit only until end of ball).

In the machine config file, you should tag the lamp that indicates
an extra ball is lit as @code{extra-ball}, and the shoot again lamp
as @code{shoot-again}.  Then the lamps will automatically update for you
when these APIs are called.

@table @code
@item light_easy_extra_ball
Lights an easy extra ball.
@item light_hard_extra_ball
Lights a hard extra ball.
@item eb_light_adjustable
Lights an easy or hard extra ball, depending on the value of an adjustment.
@item collect_extra_ball
Call this from the switch handler of the shot that scores the extra ball.
@item can_award_extra_ball
Returns true if an extra ball is allowed to be lit/awarded.  This
consider limits of extra balls per game.
@end table

There is also an API @code{special_award} to award a special, but
it does not manage any lamps automatically.  It just obeys the adjustment
to award whatever has been configured for special, and fires the knocker.

@section Tournament Mode

FreeWPC implements a tournament mode module.  Note this is what newer
Stern games refer to as @emph{competition mode}.

Tournament mode can be enabled globally in the adjustments menu, or
it can be enabled by holding down the left flipper button briefly
before starting the game.  A message will indicate that tournament mode
has been enabled.  It affects all players in the game.

Software should check the @code{tournament_mode_enabled} boolean variable
to determine if tournament is in effect.

@section Ball Search
@cindex Ball searching

Machines don't need to do much to produce a working ball search function.
The common code knows how to pulse all of the regular solenoids.
It also knows @emph{not} to fire anything marked as a @code{motor}
or @code{flasher}.
You can mark a solenoid in the machine description with @code{nosearch}
to ignore other solenoids as well.

Machines that need to handle a particular power driver in a non-standard
way (by using a template driver) should implement a @code{ball_search}
event handler, and mark the
associated solenoid as @code{nosearch}.
The @code{ball_search} handlers will be called along with the automatic
pulsing.

For example, on Funhouse, the Rudy saucer eject needs to make sure that
the mouth is open before kicking.

Solenoids associated with ball devices will be skipped unless they are empty,
except after several ball searches have failed.

Game code can call @code{ball_search_timeout_set} to set the amount of
idle time that must expire before a ball search will occur.  The default
is 15 seconds.  The timer resets anytime a playfield switch (one marked
with the @code{SW_PLAYFIELD} flag) triggers.  You can also manually reset it
manually using @code{ball_search_timer_reset}.

@section Knocker Driver

Call @code{knocker_fire} to fire the knocker.  If a coin meter is attached
to the knocker coil, it will not be pulsed.  If the machine defines a sound
effect for knock, that will be played instead of pulsing a solenoid.

@section Adjustments

Adjustments are 8-bit variables kept in persistent storage.  Each group
of related adjustments is checksummed to verify integrity.  Adjustments
can be checked by just reading the variable; there is no special API to do so.

@section Audits

Audits are 16-bit variables kept in the non-volatile area of memory.  They
are generally incremented via the @code{audit_increment} API, which adds 1.
They can also be incremented by an arbitrary value, via @code{audit_add}; or
they can be assigned via @code{audit_assign}.  They will not overflow if the
maximum value is reached, but instead will just stop counting up.

@section Scoring

A global playfield multiplier is supported; use @code{score_multiplier_set} to
change it.  It is automatically set to 1 at the beginning of each ball.

Scores can be stated in two ways: as a 5-byte, binary-coded decimal value, or
as an 8-bit "score code".  The long values allow for arbitrary values up to
one billion points.  The short values are more compact and index a table of
common score values, which are listed in the machine config.

The first set of APIs operate on arbitary BCD score buffers:

@table @code
@item score_zero
Zeroes a score.
@item score_copy
Copies one score to another.
@item score_add
Adds one score to another.
@item score_sub
Subtracts one score from another.
@item score_mul
Multiples a score by an integer.
@item score_compare
Compares two scores, as memcmp would do.
@end table

The second group of APIs increment the current player's score by
a fixed value.

@table @code
@item score
Award score.  The input is an 8-bit score code.
@item score_long
Also awards score.  The input is another BCD score buffer.
@item score_multiple
Like @code{score()}, but also takes a multiplier argument.  This multiplier
@emph{and} the global score multiplier are taken into account.
@item score_long_multiple
Like @code{score_long} and @code{score_multiple}.  This is the most
low-level API; all others ultimately call it.
@item score_long_unmultiplied
Awards score without any multipliers.
@end table

The third group of APIs, called the @dfn{ladder APIs}, add score according
to some rule.

A @dfn{fixed ladder rule} tracks the current value of a shot, and defines a
base value, an increment, and a maximum value.

@table @code
@item fixed_ladder_reset
Reset the value of the rule to its base.
@item fixed_ladder_advance
Advance the value of the rule by the increment.  The new value is checked to
make sure that it does not exceed the defined maximum.
@item fixed_ladder_score
Add the current value of the rule to the player's score.
@item fixed_ladder_scorex
Add the current value of the rule, multiplied by some constant, to the player's score.
@item fixed_ladder_score_and_advance
Add the rule value to the player and advance it by one step.
@item fixed_ladder_scorex_and_advance
Add the rule value multiplied to the player and advance it by one step.
@end table

@section Lamp Timers

A lamp timer is a countdown timer which is tied to a playfield lamp.
The amount of time remaining controls how fast the lamp flashes.  When
the timer reaches zero, the effect stops.

You declare a structure of type @code{struct lamptimer_args}, which
names the lamp and the initial timer value, in seconds.

The lamp is modified as part of an internally generated lamp effect (meaning
that it behaves just like a leff, but it does not have a lamp effect ID); thus,
the basic state of the lamp is retained.  While the lamp timer runs, the
basic state is overriden by the effect.

@table @code
@item lamp_timer_start
@item lamp_timer_find
@item lamp_timer_stop
@end table

@section Diagnostics

@section Score Rank

The score rank module is optional, based on the value of @code{CONFIG_SCORE_RANK}.
When enabled, the system will
monitor the relative changes in players' scores over the course of a multi-
player game, and throw a @code{rank_change} event whenever the current player
moves into a new place.  It is up to each game to decide how to handle it.

@section Timed Modes
@cindex Timed modes

To write a timed mode, you need to do two things:

First, create a structure of type @code{struct timed_mode_ops} and fill out
all of the required information:

@itemize @bullet
@item An initialization function.  This is called when the mode is started.
@item An exit function.  This is called when the mode is stopped or times out.
@item A task group ID.  Choose any name you want begin with @code{GID}.
When the mode is started, a task will be created with this group ID.
@item A music code.  Use MUS_NONE if the mode should not update the background music.
@item The background display effect ID.  Use DEFF_NULL if none is needed.
@item The mode end display effect ID.  Use DEFF_NULL if none is needed.
@item A priority value.  Use one of the PRI values.
@item The initial mode timer, in seconds.
@item A pointer to a timer variable.  You must declare the variable yourself.
@item The length of the grace period, in seconds.  It may be zero.
@item A pause function.  This function is called occasionally while the mode
is running.  If it returns TRUE, the timer is not advanced.
Use @code{system_timer_pause} when the mode should pause for the "usual cases" only.
Use @code{null_false_function} if the mode should not pause at all.  You can
supply your own function if you need custom behavior.
@end itemize

You must make sure that the structure and all of the functions that it references
are in the same .c file, otherwise ROM paging will not work.

Second, handle several system events which affect the mode's operation:

@table @code
@item timed_mode_music_refresh.
Call this from a @code{music_refresh} handler, passing it a pointer to the mode ops struct.
@item timed_mode_display_update.
Call this from a @code{display_update} handler, passing it a pointer to the mode ops struct.
@end table

From outside the mode itself, other modules call these APIs to interact with
your mode.  The mode ops struct is part of the public interface.

@table @code
@item timed_mode_begin
Starts a timed mode.
@item timed_mode_end
Ends a timed mode immediately.
@item timed_mode_reset.
Resets the timer to its initial value.
@item timed_mode_add.
Adds to the timer.
@item timed_mode_get_timer.
Gets the current timer value.  This should only be used by display effects.
Note that timer can be zero and the mode is still running!
@item timed_mode_running_p
Returns true if the mode is running, for the purposes of scoring.  This returns
TRUE while the mode is in its grace period.
@item timed_mode_effect_running_p
Returns true if the mode is running, for the purposes of display and lamp effects.
This return FALSE while in grace period.
@item timed_mode_device_running_p
Similarly, but should be used when updating devices from a @code{device_update}
function.
@end table

@section Ball Savers
@cindex Ball save

@section Ball Serve
@cindex Ball serve

The ball serve module is the preferred API for adding balls to play.
It uses the ball tracking APIs to program the ball trough, but adds
support for autoplunging and multiball logic.

The system supports games with autoplungers or manual plungers.
Auto launch support requires that the machine defines three things:
the launch button switch, the launch solenoid, and a shooter switch.

The base API @code{serve_ball} simply kicks a ball out of the trough.
It also resets the valid playfield flag and refreshes background effects.
This is the same call made by the game state machine during start ball.

Use @code{serve_ball_auto} instead if you want to ball to be autolaunched
as soon as it is served successful.  Otherwise, it is identical.  If
a ball is served without autolaunch, it can be launched later by calling
@code{launch_ball}.  This happens automatically when the launch button is
pressed.

You normally do not need to call either of those APIs, except in some
rare cases.

The preferred way to start multiballs is to use @code{set_ball_count},
which sets the number of balls in play, or @code{add_ball_count} if you
want to say how many balls to be added.  These use @code{serve_ball_auto}
to do the work.  They work on manual plunger games too.  Only one ball
will ever be placed in the shooter at a time.

@table @code
@item serve_ball
@item serve_ball_auto
@item launch_ball
@item set_ball_count
@item add_ball_count
@end table

@section Multiball Modes
@cindex Multiball

@section Mute and Pause Mode

FreeWPC implements the Mute and Pause feature that was included
in the Twilight Zone home ROM.  It is optional at compile-time.
The machine must have an extra-ball buyin button for it to work.

When compiled in, and the adjustment "MUTE/PAUSE" is set to YES,
then pressing buytin during a game will hold the flippers,
disable ball kickouts, and turn off the background music.  To
continue, press the button again.  It will also timeout automatically
after 15 minutes.

@section Status Report

@c ======================================================
@node Fonts and Graphics
@chapter Fonts and Graphics
@cindex Fonts
@cindex Graphics
@cindex Frames

This chapter explains in detail how FreeWPC fonts and graphics work.

FreeWPC uses simple bitmaps to represent fonts, icons, and full-screen
graphics.  A @dfn{bitmap} is an array of rectangular pixel data.
The data bits are prefixed by a short header which contains the width
and height information.  The image is stored one row at a time, starting
from the top.  Within a row, the bits are stored in little-endian format,
with the least significant bit representing the leftmost pixel.

A @dfn{font} is a set of bitmaps mapped to a contiguous sequence of
characters.  The font header identifies the ASCII code for the first
bitmap that is represented; this saves space by not needing to encode
the low-valued ASCII control characters.  The nominal height of the
characters is also defined, which allows for descenders.

A @dfn{frame} is a full-screen bitmap, 128x32.  Since these are fairly
common, special APIs are used to draw them that are more optimal, and
the width/height is implied and not actually stored in the bitmap.
A frame can have 4 colors per pixel (3 shades plus black) so
the frame is actually stored as two consecutive @dfn{bit planes}.

@section Compression

Each bit plane of a frame can optionally be compressed using run-length
encoding (RLE) or zero suppression to save space.  An uncompressed
frame requires 1KB, which limits the total number of frames in a ROM
significantly.  Every frame header includes
a flags field, which indicates which if any compression method was used.
The frame decoders are written in assembly language in @code{platform/wpc/dmd.s}.

Compression is a balance between ROM size and processor speed.  The best
compression methods would take far too long for the 6809 to decode.  The
methods used strike a compromise.  In particular, bitwise operations are
avoided in the decoders because of the 6809's inability to do bitlevel
operations quickly.

@itemize @bullet

@item Run-Length Encoding

Useful for images that contain long sequences of the same byte value.
Each long run is replaced by a 3-byte code: the first byte is the code
0xA8, which signals an @dfn{escape sequence}, the second byte is the
number of bytes divided by 2 (so the length must be even), and the
third byte is the repeated value.  A special two-byte code also
indicate end of frame, so that the decoder does not need to count
the number of decoded bytes.

@item Sparse Encoding

The sparse format encodes images that contain mostly zeroes, or
which have large transparent sections that do not require writing
to the display.  The image is encoded as a series of
(length, data, move) triples, where the @var{move} value says how
many bytes forward to move the cursor.

@end itemize

@section Using TrueType Fonts

The script @command{fontgen2} converts TrueType font files (.ttf files)
into WPC font files (.fon).  Not all characters are supported; in particular,
lowercase characters are not included by default in order to save space.
Trying to display any characters not included in the font will generally
cause a system crash, as there is not much error checking.

@section Printing Text
@cindex Text formatting
@cindex Printing text

The @code{font_render_string} family of APIs is used to draw text to
the display.  The arguments are a font object, the x and y coordinates
where the string should be placed, and a string.  The string can be
a constant string literal or the global format buffer (see below).

There are three variants which justify the text differently: centered,
left-justified, and right-justified.  Centering is done both vertically
and horizontally; the others only justify left-to-right, and the y
coordinate always specifies the top of the print area.

Text printing is CPU intensive.  Display effects should take care not to
print text more than needed.  It is often more efficient to print strings
to an overlay buffer, and then copy them to the main display page, if the
same text needs to be printed over and over again.

@section Formatting Text

FreeWPC contains a @code{printf}-like function for formatting text
strings with variable data, however, it is not quite the same.

The @code{sprintf()} function formats a string into a unique,
@emph{global} buffer named @code{sprintf_buffer}.  It is like the
actual C function of the same name, but the first argument is implied.

The format specifiers are also slightly different.  Here is a list of
the valid ones:

@table @code

@item %b

Print a binary-coded decimal value.  The format length gives the total
number of digits; for example, @code{%8b} would print a 4-byte BCD
string containing 8 digits.  Also, this format will insert commas
(or periods) between digits as necessary.

@item %c

Print a single 8-bit ASCII character.

@item %d

Print an 8-bit decimal integer (declared @code{U8}).

@item %E

When this is the first specifier in a string, it will cause
all output to be appended to the previous string in the print
buffer, rather than overwriting it completely.

@item %ld

Print a 16-bit decimal integer (declared @code{U16}).

@item %lx

Print a 16-bit hexadecimal integer (declared @code{U16}).

@item %p

Print a pointer.

@item %s

Print a string.

@item %w

Print a 32-bit hexadecimal integer (declared @code{U32}).

@item %x

Print an 8-bit hexadecimal integer (declared @code{U8}).

@end table

Like in C, you can insert a number in front of the format letter to
limit the output to a particular width.  If the length begins with
'0', then it will be padded with leading zeroes if necessary.

The formatter does not support signed numbers, and will print them as
if they were declared unsigned.

The formatter is not particularly efficient for printing large decimal
values, as the 6809 is not very good at long division.

@section Frame List
@cindex Image map
@cindex Frame list
@cindex Image linker

The list of all frames compiled in the ROM is defined in an
@dfn{image map}.  This is a machine-specific file that says which
images to copy into the final ROM image.

There can be multiple frame list files.  The common code
provides a frame list of standard images, like the FreeWPC logo,
which go into every build.

Each entry in the image map gives an image to be imported, such as a
PGM graphics file, plus an optional @dfn{frame ID}.  The frame ID becomes
a C #define that refers to the image from the source code.
The image linker writes a file @file{build/imagemap.h} which
contains a list of all the frame IDs.  Frame IDs are optional for
the internal frames in a sequence (a for loop would only need to name the
starting and ending frame).

It is the job of the image linker to decide what compression techniques
to perform.  The linker is told the maximum amount of space that can be
used for images, which is the total size of the ROM minus any sections
reserved for source code.  If all images fit without compression, then all
is well.

Otherwise, the linker will perform as much as compression as
necessary.  At present, images are compressed in the order that they
were declared.  A future enhancement would be to start with those images
that can be compressed the best without requiring much more CPU power
to decode them.

In some rare cases, trying to compress an image fails to produce a
smaller buffer.  The linker notices this and leaves such images
uncompressed.

@c ======================================================

@node System Initialization
@chapter System Initialization
@cindex Initialization sequence

Game developers do not generally need to understand all the details of
initialization.  However, this may be of interest to system developers.

Here is a rough outline of the steps taken to initialize the FreeWPC
environment:

@itemize @bullet
@item On real hardware, the processor's RESET handler is called.
On WPC, the reset handler is written in assembly language.  It performs
a ROM checksum test and a RAM test.
@item The program's @code{main} function is called (on real hardware,
this is called from the RESET handler; in simulation, this is called
by the OS like any other executable).  @code{main} is a platform-dependent
function.  It can be thought of as the continuation of low-level
initialization, except written in C.
@item @code{main} calls into @code{freewpc_init}, where the common
initialization begins.  This is defined in @file{kernel/init.c}.
@item All of the hardware-related subsystems are initialized.
@item The task scheduler is initialized.  This transforms the single thread
of execution into a legitimate task.
@item Interrupts are enabled.  Hardware systems that depend on interrupts
are now fully functional.  Also, the system clock begins to tick, which
allows tasks to sleep and therefore multitasking is fully supported.
@item Software subsystems are initialized.  The @code{init} event is thrown
here, so any new subsystems added just need to catch this event to initialize
themselves.  It is important that modules do not interact with each other during
this phase, because the order of init calls is not guaranteed.
@item Periodic functions are enabled.
@cindex Power-up message
@item The system powerup display effect is started.
@item The @code{init_ok} event is thrown to allow modules to perform a final
initialization, which may require interaction with each other.  Modules can
return FALSE if a factory reset is required.  In that case, the system will
reboot after performing the factory reset.
@item The @code{init_complete} event is thrown, to signal that all modules are
ready.
@item The main task exits, and initialization is complete.
@end itemize

@c ======================================================

@node Platform APIs
@chapter Platform APIs
@cindex Platforms
@cindex Hardware platforms

The platform APIs define how the hardware is accessed on a particular
platform.  They only need to be written once, and then all games on that
hardware architecture can be supported.

If you are developing code for a WPC machine, you do not need to understand
the platform APIs in detail, because they are already written for you.
If you plan to port FreeWPC to a different hardware architecture, then
you will need to write these functions first before you can create any
game code.

Every platform must define a header file in
@code{include/@file{platform}/@file{platform}.h}.
This file defines a number of inline functions, all of which begin with
@code{pinio}.  It also defines a handful of constants, which begin
with @code{PINIO}.

Platform APIs are the functions that perform the physical I/O.  On WPC,
these functions read and write the WPC ASIC registers.  All reads and writes
to I/O registers should use the @code{readb} and @code{writeb} macros.
How these work depends on the platform.  For most platforms, these turn into
memory-mapped operations.  However, they could also use a parallel port or
USB.

Platform APIs are not
suitable for game code to call directly, as they are too low-level.  Instead,
game code uses the core APIs to access a device driver; the device driver then
uses the platform APIs.

@table @code

@item pinio_write_switch_column

Set the current switch matrix column.

@item pinio_read_switch_rows

Read all of the switches on the currently selected column.

@item pinio_read_dedicated_switches

Read all of the dedicated switches.

@item pinio_read_flippers

Read all of the Fliptronic switches.

@item pinio_read_flipper_buttons

Read all of the Fliptronic button switches.

@item pinio_read_flipper_eos

Read all or some of the flipper switches.

@item pinio_read_locale

Read the locale indicator (jumpers or DIP switches).

@item pinio_write_lamp_strobe

Set the current lamp matrix strobe.

@item pinio_write_lamp_data

Write lamp row data for the currently selected column.

@item pinio_write_solenoid_set (@var{bank}, @var{value})

Refresh a set of 8 solenoids.

@item pinio_read_ac_zerocross (CONFIG_AC)

Return nonzero if currently at a zerocross point.

@item pinio_reset_sound

Reset the sound board.

@item pinio_write_sound

Write an 8-bit code to the sound board.

@item pinio_sound_ready_p

Return true if the sound board has an 8-bit waiting to be read.

@item pinio_read_sound

Read an 8-bit code from the sound board.

@item pinio_write_gi (CONFIG_GI)

Write to the set of all general illumination strings.  This API
is only used when the platform does not support dimming.

@item pinio_read_triac (CONFIG_TRIAC)

If the platform supports dimming through triacs, this call returns the
input-side latch values.

@item pinio_write_triac (CONFIG_TRIAC)

Write to the triacs.  This API is only used when the platform supports dimming.

@item pinio_watchdog_reset (CONFIG_WATCHDOG)

Reset the hardware watchdog timer.

@item pinio_active_led_toggle (CONFIG_DIAG_LED)

Toggle the diagnostic LED.

@item pinio_dmd_window_set (CONFIG_DMD)

Sets the display page that is mapped into a given portion of the CPU address space.

@item pinio_dmd_window_get (CONFIG_DMD)

Returns the display page that is mapped into a given portion of the CPU address space.

@item pinio_dmd_window_ptr (CONFIG_DMD)

Returns a pointer to the beginning of the buffer that is mapped into a given portion
of the CPU address space.

@item pinio_dmd_set_visible (CONFIG_DMD)

Sets the display page that is currently visible on the display.

@item pinio_dmd_request_interrupt (CONFIG_DMD)

Request that an interrupt be generated when the DMD controller finishes
refreshing the display.

@item pinio_parport_write (CONFIG_PARALLEL_PORT)

Write a byte to the parallel port.

@item pinio_set_bank (CONFIG_BANK_SWITCH)

Writes to a bank switching register.  There may be multiple such registers;
you specify which register, and the value to be written.  The values
are also platform specific.

@item pinio_get_bank (CONFIG_BANK_SWITCH)

Reads the value of a bank switching register.

@item pinio_read_timer (CONFIG_HIGHRES_TIMER)

@item pinio_write_timer (CONFIG_HIGHRES_TIMER)

@end table

@c ======================================================
@node Native Mode
@chapter Native Mode
@cindex Native mode
@cindex Simulation

Native mode lets you run FreeWPC directly on your host build machine.
It is a form of emulation, like PinMAME, except the emulator is
"built-in" to the game program itself.  It works on both Linux and
Cygwin systems.

There are two major differences in a simulation build.  First, certain
low-level OS and CPU specific features must be replaced by new components that
work under your native operating system environment.  In particular, 6809
assembly language functions are not used at all in this mode.  We use either
portable C versions of these functions, or comparable functions that are
provided by the host OS.

Second, I/O reads and writes do not directly control real hardware, but
are instead emulated internally by the program itself.  All I/O is
initiated by the platform APIs and uses the @code{readb} and @code{writeb}
functions to address the hardware.  In native mode, these functions define
a separation between the "program" and the "simulation".

Native mode is most useful for debugging and testing the higher layers
of FreeWPC, which aren't as hardware or timing dependent.  This is only
possible because the majority of the code is written in C.

To compile in native mode, just add @code{NATIVE=y} to your @file{.config}.
Instead of a ROM, you'll get an executable that can be run directly.

@menu
* Thread Model::           How tasks and interrupts work in simulation
* Persistent Memory::      How to simulate persistent variables
* Input and Output::       How the hardware I/O is emulated
* GDB Debugging::          Debugging the program using GDB
* Interrupt Tracing::
* Platform Emulation::
* Timing::
* Command Language::
* Variables::
* User Interface::
* Hardware Emulation::
* Signal Tracking::
@end menu

@node Thread Model
@section Thread Model

Native mode programs are no longer realtime.  There are two main concerns related
to scheduling.

First, normal multitasking (the task_xxx APIs) is accomplished using
the @emph{pth} library, an
open source, nonpreemptive thread library.  A thin wrapper maps the core
task APIs to their pth equivalents.

Periodic functions are called occasionally from a special thread instead of
the FreeWPC scheduler.

Interrupts are also simulated from an ordinary thread.  The native operating
system probably does not allow threads to sleep for as little as 1ms; on
Linux the minimum sleep time is on the order of 10-20ms instead, and under
Cygwin, it may be even longer.
When the interrupt thread is woken up, it checks the system clock to see
how much time has actually elapsed, and invokes the interrupt handler
@emph{multiple times}.  The net effect is that interrupt handlers are invoked
the same number of times as they would be on real hardware, but not the same
way: they are called in batches, rather than being equally spread out.

By default, the simulation runs at the same speed as the native system clock.
It is possible to speed up the simulation by a constant multiplier, which
is sometimes helpful for rapid testing.

@node Persistent Memory
@section Persistent Memory

Permanent and non-volatile variables are supported; their values are
saved in files across program runs.  Non-volatile variables are not
actually write-protected though.  This may be implemented in the future.

@node Input and Output
@section Input and Output

The native program includes a simple, curses-based user interface to show
what it is doing.  Switches, lamps, solenoids, and GI states are redrawn in
the window as necessary.  Also, the DMD or alphanumeric display is emulated.

The UI support is separated into a separate module from the core emulation,
and could be replaced by something more sophiscated in the future, for
example, using a window library like Qt or GTK.

Switches can be simulated by pressing keys.  The ESC key terminates the
simulation.  Many of the key mappings are the same as what is offered in
PinMAME.

Advanced simulation techniques, such as ball movements, are only partially
implemented at the moment.

@node GDB Debugging
@section GDB Debugging

You can use GDB to debug the native mode program.

Because the program uses curses to draw, it is easiest to run gdb from a separate
terminal and @emph{attach} to the running program.
See the gdb manual (@url{http://sourceware.org/gdb/current/onlinedocs/gdb/}) for more
information on how this works.  Basically, you only need to know its process ID.

If you are in the FreeWPC source tree, you can run @code{make attach} to do this
automatically.  If it finds a running program, it will attach, halt the program
(you'll see everything freeze), then give you a debugger prompt.

From here, you can set breakpoints, step through the code, etc.  If the program
crashes, you can use the @code{bt} command to get a backtrace and see exactly
where it failed.

@node Interrupt Tracing
@section Interrupt Tracing

Since interrupt handlers are really just ordinary functions in native mode,
they are much easier to debug.  You can use printf and other functions that
would normally be off-limits.  The @code{interrupt_dbprintf} function can
be used; in 6809 mode, this is a macro which does nothing, while in native
mode it equates to a regular @code{dbprintf}.

@node Platform Emulation
@section Platform Emulation

Much like FreeWPC itself is portable, the builtin simulator is also designed
to be portable.  Its architecture is structured similarly in layers that
isolate the platform and machine specific parts.

The interface between the simulator and the target system are the
@code{readb} and @code{writeb} functions.  I/O initiated by the target
is intercepted by the simulator.  The simulator itself catches these calls.
Platforms register callbacks for addresses that can be simulated.

@node Timing
@section Timing

@node Command Language
@section Command Language

The simulator allows you to control it via a command language.  While
the program is running, you can enter commands via the user-interface.
You can also load scripts of commands from files.

Some files are checked automatically at startup and these commands are
always run.  These are kept in the @file{conf} subdirectory of the source
tree.  First, it will load @file{conf/freewpc.conf}.  Then it will load
a machine-specific file, @file{conf/@var{machine}.conf}.

In the curses-based simulator, press the colon key (like in vi) to
open a command prompt.  Other UIs may be different.

The basic commands are listed below.  See other sections for more commands
that are more specific.

Because commands can be placed in script files, shell-style comments and
blank lines are accepted and ignored.

@table @bullet
@item set @var{var} @var{value}
@item print @var{var}
@item include @var{file}
@item sw @var{switch}
@item swtoggle @var{switch}
@item key @var{keyname} @var{switch}
@item push @var{value}
@item pop @var{argcount}
@item sleep @var{time}
@item exit
@end table

@node Variables
@section Variables

The simulator uses variables in certain places to allow you to change its
behavior at runtime.  The @code{set} and @code{print} commands work on these
variables.

All variables are fundamentally of type @code{int}.  There is no support for strings.

Simulator modules declare variables in the usual way, then export these to the
variable tracker using @code{conf_add}.  This associates a public name for the variable
that the command language sees.  When variables are modified in this way, the module's
int variables are then modified directly.

@node User Interface
@section User Interface

@node Hardware Emulation
@section Hardware Emulation

@node Signal Tracking
@section Signal Tracking

@c ======================================================
@node Debugging
@chapter Debugging

@section @code{dbprintf}

You can use the @code{dbprintf()} function to print debug
messages.
@code{dbprintf} uses the builtin @code{sprintf} function to format
the message, and then calls @code{db_puts} to print it.
How these messages are printed depends on which version of
@command{pinmame} you are using.  At present, there is no way
to see these messages when you are running on real hardware.

If you are running Linux, and you obtain the patches to @command{xpinmame},
each character is written to a new hardware register, the
@dfn{debugger port}.  It acts like a serial port and can
be used to communicate between the game program and a
separate debug console.  The program @command{wpcdebug} is
the console.  Run this at the same time as pinmame and you
will see the debug messages printed out.  The two programs
use a local socket to send data back and forth.

The console also accepts keyboard input and passes it back
to the running program.  See @file{common/db.c} for more information.

Under an unpatched emulator, such as on Windows, debug messages are
sent to the WPC parallel port.  @code{pinmame}
writes the printer output to a file in the @file{memcard} directory.
Under Windows, these files cannot be read while the program is
still running.

In either case, the code to drive the serial/parallel port is only
enough to keep the emulator happy; none of it would work on real hardware.

@section @command{gdb}

In native mode only, you can use @command{gdb} as you would on
any other program.  Because native mode uses @command{ncurses}, however,
it is best to run the debugger in a separate window from the program
itself.

Start FreeWPC as usual, then from another window, run @command{make attach}.
(See the Makefile to see what this does; you really don't need to be
in the source tree to do it.)  gdb starts, searches for the PID of the program,
and attaches to it.  The program will stop, and you can then control it from
the gdb prompt.

There are some special gdb macros provided in @file{gdbmacros}.
All of the usual breakpoints, stepping, and variable evaluation
commands work as you would expect.

@section @command{exec09}

exec09 is the 6809 emulator that is provided with GCC6809.
exec09 supports a subset of the WPC architecture and can be used
as a replacement for PinMAME.  It is mostly good for debugging
straight CPU code that does not access hardware.  It provides
a command-line monitor with breakpoints, single-step, and symbolic
debugging which is sometimes more useful than PinMAME or gdb.

exec09 can measure the length of time a function takes, including
interrupt handlers, which is good for determining performance.

@section Breakpoints

FreeWPC now supports breaking into the game program when the compile-time
flag @code{CONFIG_BPT} is turned on.  This works both in emulators and on
real hardware.  When enabled, this feature overrides the normal use of the
Escape coin door button.  Pressing Escape now halts the system; press Escape
again to resume.

While halted, you can use the Up and Down buttons to view memory.

If a fatal error occurs when the debugger is compiled in, the machine will
fall into the debugger instead of rebooting.  This will show you what
error occurred and which task was last running.

When halted, only normal task scheduling and periodic functions cease to run.
Interrupt handlers/realtime functions cannot be halted, and thus, if they
fail, the system will behave erratically.  (Smoke alert.)

You can also dynamically enable and disable breakpoints at various places
within the code, so that the debugger will start when the program hits that
location, without having to press Escape.

@section Switch Stress Test

The switch stress test is used to test switch handling over a long
period of time.  When enabled, this adjustment causes the game to
pretend that switch closures are occurring randomly.  No balls are
actually put into play, but the machine is fooled into thinking so.

Stress test also exercises ball devices correctly, and simulates 'enter'
events instead of individual device switches.  Ball locks, trough
serves, and multiballs can all be tested.

You can force end-of-ball by pressing the Start Button several seconds
after the start of the ball (the delay allows you to still add players
to test multiplayer games).  If in multiball play, pressing Start
simulates the drain of exactly one ball at a time.

Closures are simulated randomly at a rate of about 10 per second.
This test has been used to uncover some hard to find bugs in the game
logic after extended play.

Naturally, this feature is disabled by default.

@c ======================================================
@node The WPC Hardware
@appendix The WPC Hardware

@include hardware.texi

@c ======================================================
@node The Machine Definition
@appendix The Machine Definition

@include md.texi

@c ======================================================
@node System Events
@appendix System Events

Here is a list of all of the standard events that the system generates.

@include events.texi

@c ======================================================
@node Build Tools
@appendix Build Tools

@section csum : ROM Checksum Tool
@cindex Checksumming
@cindex ROM checksum

The checksum tool works on FreeWPC ROMs as well as the original
Williams factory ROMs.  It can verify and update the checksum
field located just above the interrupt vector table.

The checksum is a 16-bit value that resides at logical address
0xFFEE (18 bytes from the top of ROM).  This value should equal the
sum of all the 8-bit byte values in the ROM, modulo 65536.  The
checksum word is itself included when calculating and verifying it.

@command{csum} also uses the word at address 0xFFEC as a
@dfn{fixup word}, which can be set to any value to help make the
checksum match.

@section srec2bin : S-Record Converter
@cindex S-records

The gcc6809 linker produces S-record files by default.  This
tool converts S-records to raw binary format.

Each bank of the ROM is linked individually; each produces an S-record
file.  These files contain nearly everything to generate a binary file,
except for the size and the value to place at holes.  We use 0xFF
for all holes as this is more friendly to EPROMs.

@section sched : Static Scheduler

The scheduler reads in a list of schedule files, which by
convention end with the extension @file{.sched}.  Each entry gives
a function and a frequency at which it should be called.
It generates a C source file that contains a top-level function
which then calls all of those functions at the right rate.  It does
this by keeping a counter of the number of times that the top
function was called.

The scheduler supports @dfn{loop unrolling}, where the top
function is actually decomposed into a small number of functions.
This reduces the number of if-statements needed overall; it does
require an extra indirection via function pointer.  This can
cause code duplication for the sake of speed.  The unroller tries
to balance all of the functions to be scheduled using performance
data in the schedule file.

@section fontgen2 : TrueType Font Generator
@cindex Font conversion

This is a short Perl script which can transform a TrueType
font file (@file{.ttf}) into FreeWPC source code.  It requires
the @command{convert} program from the ImageMagick tool suite.

@c ======================================================

@include dmd-theory.texi

@node Historical Notes
@appendix Historical Notes

FreeWPC was started in 2005 and was written entirely in assembly language,
before the availability of the gcc6809 C compiler.  An initial attempt
to ease programming involved the use of some complicated macros, written
in the @command{m4} programming language.  Work was halted during the
development of gcc6809, then the system was gradually rewritten in C.
The early source code repository actually contained the compiler changes
as well.

The first time that a FreeWPC ROM was placed into a game was in
May, 2008.  It did not run OK due to some problems with the watchdog
circuit and with the PIC initialization.  Those problems were
resolved within only a few hours.

@node Design Principles
@appendix Design Principles
@include howto.texi

@node Concept Index
@unnumbered Concept Index
@printindex cp
