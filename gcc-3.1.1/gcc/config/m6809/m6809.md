;;- Machine description for GNU compiler on the Motorola 6809 processor
;;-
;;- Major cleanup and bug fixes by Brian Dominy 
;;-    (brian@oddchange.com)
;;-
;;- Minor changes to adapt it to gcc-2.5.8 by Matthias Doerfel
;;-    (msdoerfe@informatik.uni-erlangen.de)
;;- Also added #pragma interrupt (inspired by gcc-6811)
;;- 
;;- Original Version by Tom Jones (jones@sal.wisc.edu)
;;- Space Astronomy Laboratory
;;- University of Wisconsin at Madison
;;-
;;- Copyright (C) 1989, 2005 Free Software Foundation, Inc.
;;
;; This file is part of GNU CC.
;;
;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 1, or (at your option)
;; any later version.
;;
;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
;;
;;

;;--------------------------------------------------------------------
;;-  Constants
;;--------------------------------------------------------------------


;;- Instruction patterns.  When multiple patterns apply,
;;- the first one in the file is chosen.
;;-
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
;;-
;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;; Put tstsi first among test insns so it matches a CONST_INT operand.
;;--------------------------------------------------------------------
;;-  Test
;;--------------------------------------------------------------------

(define_insn "tstsi"
  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
  ""
  "cmp%0\\t#0\\t;tstsi: R:%0")

(define_insn "tsthi"
  [(set (cc0) (match_operand:HI 0 "register_operand" "r"))]
  ""
  "cmp%0\\t#0\\t;tsthi: R:%0")

;;*** NOT USED ***;; (define_insn ""
;;*** NOT USED ***;;   [
;;*** NOT USED ***;;     (set (cc0) 
;;*** NOT USED ***;;       (and:QI (match_operand:QI 0 "byte_reg_operand" "q")
;;*** NOT USED ***;;         (match_operand:QI 1 "immediate_operand" "i")))
;;*** NOT USED ***;;   ]
;;*** NOT USED ***;;   ""
;;*** NOT USED ***;;   "bit%0\\t#%1\\t;tstqi(andqi): R:%0")

(define_insn "tstqi"
  [(set (cc0) (match_operand:QI 0 "byte_operand" "qm"))]
  ""
 "*
{
  if (GET_CODE (operands[0]) == MEM)
    return \"tst\\t%0\\t;tstqi: MEM:%0\";
  else
    return \"tst%0\\t\\t;tstqi: R:%0\";
}")

(define_insn ""
  [(set (cc0)
        (match_operand:SI 0 "memory_operand" "m"))]
  ""
  "tst\\t%0\\t;tstsi: MEM:%0")

;;--------------------------------------------------------------------
;;- Compare
;;--------------------------------------------------------------------
;; Put cmpsi first among compare insns so it matches two CONST_INT operands.


;;- cmpsi for register to memory or register compares
(define_insn "cmpsi"
  [(set (cc0) 
    (compare (match_operand:SI 0 "general_operand" "ad,g,??ad")
    (match_operand:SI 1 "general_operand" "g,da,da")))]
  ""
  "*
{
  if ((REG_P (operands[0])) && (REG_P (operands[1]))) {
    output_asm_insn (\"pshs\\t%1\\t;cmpsi: R:%1 with R:%0\", operands);
    return \"cmp%0\\t,s++\\t;cmpsi:\";
  }
  if (GET_CODE (operands[0]) == REG)
    return \"cmp%0\\t%1\\t;cmpsi:\";
  else {
    cc_status.flags |= CC_REVERSED;
    return \"cmp%1\\t%0\\t;cmpsi:(R)\";
  }
}")

;;- cmphi for register to memory or register compares
(define_insn "cmphi"
  [(set (cc0)
    (compare (match_operand:HI 0 "general_operand" "ad,g,??ad")
    (match_operand:HI 1 "general_operand" "g,da,da")))]
  ""
  "*
{
  if ((REG_P (operands[0])) && (REG_P (operands[1]))) {
    output_asm_insn (\"pshs\\t%1\\t;cmphi: R:%1 with R:%0\", operands);
    return \"cmp%0\\t,s++\\t;cmphi:\";
  }
  if (GET_CODE (operands[0]) == REG)
    return \"cmp%0\\t%1\\t;cmphi:\";
  else {
    cc_status.flags |= CC_REVERSED;
    return \"cmp%1\\t%0\\t;cmphi:(R)\";
  }
}")


(define_insn "cmpqi"
  [(set (cc0)
    (compare (match_operand:QI 0 "byte_operand" "q,mK")
    (match_operand:QI 1 "byte_operand" "mK,q")))]
  ""
  "*
{
    if (GET_CODE (operands[0]) == REG)
      return \"cmp%0\\t%1\\t;cmpqi:\";
    else {
      cc_status.flags |= CC_REVERSED;
      return \"cmp%1\\t%0\\t;cmpqi:(R)\";
    }
}")


;;--------------------------------------------------------------------
;;-  Move
;;--------------------------------------------------------------------

;;*** NOT USED ***;;   ;;-(define_insn "movdi"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:DI 0 "memory_operand" "=m")
;;*** NOT USED ***;;   ;;-   (match_operand:DI 1 "memory_operand"  "m"))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "*
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    return \".bogus ;movdi: %1 -> %0\";
;;*** NOT USED ***;;   ;;-}")

;;*** NOT USED ***;;   ;;- new insn for arrays
;;*** NOT USED ***;;   ;;-(define_insn ""
;;*** NOT USED ***;;   ;;-  [(set (match_operand:QI 0 "byte_operand" "q,q")
;;*** NOT USED ***;;   ;;-   (mem:QI (plus:SI  (match_operand:SI 1 "general_operand"  "d,a")
;;*** NOT USED ***;;   ;;-   (match_operand:SI 2 "general_operand"  "a,d"))))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "*
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    return \".bogus ;movqi: %1,%2 -> %0\";
;;*** NOT USED ***;;   ;;-}")

;;*** NOT USED ***;;   ;;- new insn for arrays
;;*** NOT USED ***;;   ;;-(define_insn ""
;;*** NOT USED ***;;   ;;-  [(set (mem:QI (plus:HI  (match_operand:HI 0 "reg_operand"  "a")
;;*** NOT USED ***;;   ;;-                          (match_operand:HI 1 "reg_operand"  "a")))
;;*** NOT USED ***;;   ;;-        (match_operand:QI 2 "byte_operand" "qi"))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "*
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    return \".maz ;movqi: %2 -> %1,%0 \";
;;*** NOT USED ***;;   ;;-}")


;;-
(define_insn ""
  [(set (match_operand:SI 0 "general_operand"  "=r")
    (match_operand:SI 1 "memory_operand"  "m"))]
  ""
  "*
{
  return \"ld%0\\t#%1\\t;movsi: #<symbol_ref> -> %0\";
}")


(define_insn "movsi"
  [(set (match_operand:SI 0 "general_operand" "=r,r,mi")
    (match_operand:SI 1 "general_operand"  "r,mi,r"))]
  ""
  "*
{
  if (REG_P (operands[0]))
  {
    if (REG_P (operands[1])) {
      if (REGNO (operands[0]) != REGNO (operands[1]))
        return \"tfr\\t%1,%0\\t;movsi: R:%1 -> R:%0\";
      else
        return \";redundant movsi: R:%1 -> R:%0\";
    }

    if ((operands[1] == const0_rtx) && (D_REG_P (operands[0])))
      return \"clra\\t\\t;movsi: ZERO -> R:%0\;clrb\";
    else
      return \"ld%0\\t%1\\t;movsi: %1 -> R:%0\";
  }

  if ((push_operand (operands[0], SImode)) && (REG_P (operands[1])))
    return \"pshs\\t%1\\t;movsi: push R:%1\";

  if (REG_P (operands[1]))
    return \"st%1\\t%0\\t;movsi: R:%1 -> %0\";

  return \".bogus ;movsi: %1 -> %0\";
}")


(define_insn "movhi"
  [(set (match_operand:HI 0 "general_operand" "=r,r,mi")
    (match_operand:HI 1 "general_operand"  "r,mi,r"))]
  ""
  "*
{
  if (REG_P (operands[0])) 
  {
    if (REG_P (operands[1])) {
      if (REGNO (operands[0]) != REGNO (operands[1]))
        return \"tfr\\t%1,%0\\t;movhi: R:%1 -> R:%0\";
      else
        return \";redundant movhi: R:%1 -> R:%0\";
    }

    if ((operands[1] == const0_rtx) && (D_REG_P (operands[0])))
      return \"clra\\t\\t;movhi: ZERO -> R:%0\;clrb\";
    else
      return \"ld%0\\t%1\\t;movhi: %1 -> R:%0\";
    }

    if ((push_operand (operands[0], QImode))  /* bcd */
      && (REG_P (operands[1])))
      return \"pshs\\t%1\\t;movhi: push R:%1\";

    if (REG_P (operands[1]))
      return \"st%1\\t%0\\t;movhi: R:%1 -> %0\";

    return \".bogus ;movhi: %1 -> %0\";
}")


;;- clrqi
(define_insn "clrqi"
  [(set (match_operand:QI 0 "byte_operand" "=q,=m")
     (const_int 0))]
  ""
  "@
  clr%0\\t\\t;clrqi REG:%0
  clr\\t%0\\t;clrqi %0")


;;- movqi
(define_insn "movqi"
  [(set (match_operand:QI 0 "byte_operand" "=q,q,mi")
    (match_operand:QI 1 "byte_operand" "q,mi,q"))]
  ""
  "*
{
  if (REG_P (operands[0]))
  {
    if (REG_P (operands[1])) {
      if (REGNO (operands[0]) != REGNO (operands[1]))
        return \"tfr\\t%1,%0\\t;movqi: R:%1 -> R:%0\";
      else
        return \";redundant movqi: R:%1 -> R:%0\";
      }

    if (operands[1] == const0_rtx)
      return \"clr%0\\t\\t;movqi: ZERO -> R:%0\";
    else
      return \"ld%0\\t%1\\t;movqi: %1 -> R:%0\";
  }

  if (GET_CODE (operands[1]) == REG)
    return \"st%1\\t%0\\t;movqi: R:%1 -> %0\";

  if ((push_operand (operands[0], QImode)) && (GET_CODE (operands[1]) == REG))
    return \"pshs\\t%0\\t;movqi: push R:%0\";
  else
    return \".bogus ;movqi: %1 -> %0\";
}")



;; replaced with QI instead of HI
;;- set high byte of 16-bit word
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=q,q,m")
      (subreg:QI (match_operand:SI 1 "general_operand" "d,m,d") 1))]
  ""
  "*
{
  if (REG_P (operands[0]) && (operands[1] == const0_rtx))
    return \"clr%0\\t\\t;movmsb:\";
  if ((REG_P (operands[0])) && (D_REG_P (operands[1])))
    return \"tfr\\ta,%0\\t;movmsb:\";
  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"sta\\t%0\\t;movmsb:\";
  if (REG_P (operands[0]) && (GET_CODE (operands[1]) == MEM))
    return \"ld%0\\t%1\\t;movmsb:\";
  else
    return \".bogus ;movmsb: %1 -> %0\";
}")

;; replaced with QI instead of HI
;;- set low byte of 16-bit word
;; was =q,q,m
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=d,d,m")
      (subreg:QI (match_operand:SI 1 "general_operand" "d,m,d") 0))]
  ""
  "*
{
  if (REG_P (operands[0]))
  {
    if (operands[1] == const0_rtx)
      return \"clr%0\\t\\t;movlsb: ZERO -> R:%0\";
    else if (D_REG_P (operands[1]))
      return \"tfr\\tb,%0\\t;movlsb: R:%1 -> R:%0\";
    else if (GET_CODE (operands[1]) == MEM)
      return \"ld%0\\t%L1\\t;movlsb: %1 -> R:%0 (with corrected memadress)\";
  }

  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsb: R:%1 -> %0\";
  else
    return \".bogus ;movlsb: %1 -> %0\";
}")


;;- set low byte of 16-bit word
;; was =q,q,m
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=q,q,m")
      (subreg:QI (match_operand:HI 1 "general_operand" "d,m,d") 0))]
  ""
  "*
{
  if (REG_P (operands[0]))
  {
    if (operands[1] == const0_rtx)
      return \"clr%0\\t\\t;movlsbqihi: ZERO -> R:%0\";
    else if (D_REG_P (operands[1]))
      return \"tfr\\tb,%0\\t;movlsbqihi: R:%1 -> R:%0\";
    else if (GET_CODE (operands[1]) == MEM)
      return \"ld%0\\t%L1\\t;movlsbqihi: %1 -> R:%0 (with corrected memadress)\";
  }

  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsbqihi: R:%1 -> %0\";
  else
    return \".bogus ;movlsbqihi: %1 -> %0\";
}")


;; - set low byte of 16-bit word -- QI:QI-version
(define_insn ""
  [(set (match_operand:QI 0 "byte_operand" "=d,d,m")
      (subreg:QI (match_operand:QI 1 "byte_operand" "q,m,q") 0))]
  ""
  "*
{
  if (REG_P (operands[0])) {
    if (operands[1] == const0_rtx)
      return \"clr%0\\t\\t;movlsb: ZERO -> R:%0\";
    else if (D_REG_P (operands[1]))
      return \"tfr\\tb,%0\\t;movlsb: R:%1 -> R:%0\";
    else if (GET_CODE (operands[1]) == MEM)
      return \"ld%0\\t%1\\t;movlsb: %1 -> R:%0 (with uncorrected memadress)\";
  }

  if (D_REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%0\\t;movlsb: R:%1 -> %0\";
  else
    return \".bogus ;movlsb: %1 -> %0\";
} ")


(define_insn "movstricthi"
  [(set (strict_low_part
    (subreg:HI (match_operand:SI 0 "general_operand" "d,m,d") 0))
    (match_operand:HI 1 "byte_operand" "q,q,m"))]
  ""
  "*
{
  if (REG_P (operands[0])) {
    if (operands[1] == const0_rtx)
      return \"clrb\\t\\t;movstricthi: ZERO -> R:%0\";
    if (REG_P (operands[1]))
      return \"tfr\\t%1,b\\t;movstricthi: R:%1 -> R:%0\";
    else
      return \"ldb\\t%L1\\t;movstricthi: %1 -> R:%0\";
  }
  if (REG_P (operands[1]) && (GET_CODE (operands[0]) == MEM))
    return \"stb\\t%L0\\t;movstricthi: R:%1 -> %0\";
  else
    return \".bogus ;movstricthi: %1 -> %0\";
}")


;;--------------------------------------------------------------------
;;-  Swap registers
;;--------------------------------------------------------------------
(define_insn "swapsi"
  [(set (match_operand:SI 0 "register_operand" "+r")
    (match_operand:SI 1 "register_operand" "+r"))
   (set (match_dup 1) (match_dup 0))]
  ""
  "exg\\t%1,%0\\t;swapsi: R:%1 <-> R:%0")

(define_insn "swapqi"
  [(set (match_operand:QI 0 "byte_reg_operand" "+q")
    (match_operand:QI 1 "byte_reg_operand" "+q"))
   (set (match_dup 1) (match_dup 0))]
  ""
  "exg\\t%1,%0\\t;swapqi: R:%1 <-> R:%0")


;;--------------------------------------------------------------------
;;-  Extension and truncation insns.
;;--------------------------------------------------------------------
;; Those for integer source operand
;; are ordered widest source type first.

;;*** NOT USED ***;;   ;;- Use this pattern to match the insn for variable subscripts.
;;*** NOT USED ***;;   
;;*** NOT USED ***;;   ;;-(define_expand "extendhisi2"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:SI 0 "general_operand" "=d,g")
;;*** NOT USED ***;;   ;;-   (sign_extend:SI (match_operand:HI 1 "general_operand" "q,g")))]
;;*** NOT USED ***;;   ;;-    ""
;;*** NOT USED ***;;   ;;-    "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    rtx breg;
;;*** NOT USED ***;;   ;;-    rtx dreg;
;;*** NOT USED ***;;   ;;-    rtx sint;
;;*** NOT USED ***;;   ;;-
;;*** NOT USED ***;;   ;;-    breg = gen_rtx (REG, HImode, 0);
;;*** NOT USED ***;;   ;;-    dreg = gen_rtx (REG, SImode, 0);
;;*** NOT USED ***;;   ;;-    emit_insn (gen_rtx (SET, HImode, breg, operands[1]));
;;*** NOT USED ***;;   ;;-    sint = (gen_rtx (SIGN_EXTEND, SImode, breg));
;;*** NOT USED ***;;   ;;-    emit_insn (gen_rtx (SET, SImode, dreg, sint));
;;*** NOT USED ***;;   ;;-
;;*** NOT USED ***;;   ;;-    /*** assume extended value is in R0 ***/
;;*** NOT USED ***;;   ;;-    if (!D_REG_P (operands[0])) {
;;*** NOT USED ***;;   ;;-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 0));
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    DONE;
;;*** NOT USED ***;;   ;;-}")
;;*** NOT USED ***;;   ;;-


(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=g")
        (sign_extend:SI (match_operand:HI 1 "general_operand" "g")))]
  ""
  "; extendhisi2: %1 -> %0"
)

(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
    (sign_extend:SI (match_operand:QI 1 "byte_operand" "qmi")))]
  ""
  "*
{
    if (REG_P (operands[1])) {
      if (REGNO (operands[1]) == HARD_A_REGNUM)
        output_asm_insn (\"tfr\\ta,b\\t;extendqisi: R:%1 -> R:%0\;sex\", operands);
      else
        output_asm_insn (\"sex\\t\\t;extendqisi: R:%1 -> R:%0\", operands);
    }
    else {
      output_asm_insn (\"ldb\\t%1\\t;extendqisi: %1 -> R:%0\;sex\", operands);
    }
    return \"\";
}")

;;-
(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
        (sign_extend:HI (match_operand:QI 1 "byte_operand" "qmi")))]
    ""
    "*
{
  if (REG_P (operands[1])) {
    if (REGNO (operands[1]) == HARD_A_REGNUM)
      output_asm_insn (\"tfr\\ta,b\\t;extendqihi: R:%1 -> R:%0\;sex\", operands);
    else
      output_asm_insn (\"sex\\t\\t;extendqihi: R:%1 -> R:%0\", operands);
    }
    else {
      output_asm_insn (\"ldb\\t%1\\t;extendqihi: %1 -> R:%0\;sex\", operands);
    }
    return \"\";
}")



(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=d,m,?m")
    (const_int 0))
   (set (strict_low_part (subreg:HI (match_dup 0) 0))
    (match_operand:HI 1 "general_operand" "qm,q,m"))]
  ""
  "*
{
  if (D_REG_P (operands[0])) {
    if (REG_P (operands[1])) {
      if (REGNO (operands[1]) == HARD_A_REGNUM)
        output_asm_insn (\"tfr\\ta,b\", operands);
      return \"clra\\t\\t;zero_extendhisi: R:%1 -> R:%0\";
    }
  if (GET_CODE (operands[1]) == MEM)
    return \"ldb\\t%1\\t;zero_extendhisi: %1 -> R:d\;clra\";
  }

  if ((REG_P (operands[1])) && (GET_CODE (operands[0]) == MEM))
    return \"clr\\t%0\\t;zero_extendhisi: R:%1 -> %0\;st%1\\t%L0\";

  if ((GET_CODE (operands[0]) == MEM) && (GET_CODE (operands[1]) == MEM)) {
    return \"clr\\t%0\\t;zero_extendhisi: R:%1 -> %0\;lda\\t%1\;sta\\t%L0\";
  }
  else
    return \".bogus ;zero_extendhisi: %1 -> %0\";
}")



(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "general_operand" "=d")
        (zero_extend:HI (match_operand:QI 1 "general_operand" "miq")))]
  ""
  "*
{
  if (D_REG_P (operands[0])) {
    if (REG_P (operands[1])) {
      if (REGNO (operands[1]) == HARD_A_REGNUM)
        output_asm_insn (\"tfr\\ta,b\", operands);
      return \"clra\\t\\t;zero_extendqihi: R:%1 -> R:%0\";
    }
    if (GET_CODE (operands[1]) == MEM)
      return \"ldb\\t%1\\t;zero_extendqihi: %1 -> R:d\;clra\";
    }

    if ((REG_P (operands[1])) && (GET_CODE (operands[0]) == MEM))
      return \"clr\\t%0\\t;zero_extendqihi: R:%1 -> %0\;st%1\\t%L0\";

    if ((GET_CODE (operands[0]) == MEM) && (GET_CODE (operands[1]) == MEM)) {
      return \"clr\\t%0\\t;zero_extendqihi: R:%1 -> %0\;lda\\t%1\;sta\\t%L0\";
    }
    else
      return \".bogus ;zero_extendqihi2: %1 -> %0\";
}")


;;--------------------------------------------------------------------
;;-  Fix-to-float conversion insns.
;;--------------------------------------------------------------------
;; Note that the ones that start with SImode come first.
;; That is so that an operand that is a CONST_INT
;; (and therefore lacks a specific machine mode).
;; will be recognized as SImode (which is always valid)
;; rather than as HImode or QImode.


;;--------------------------------------------------------------------
;;-  Float-to-fix conversion insns.
;;--------------------------------------------------------------------


;;--------------------------------------------------------------------
;;- All kinds of add instructions.
;;--------------------------------------------------------------------

(define_insn "addsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,  =a")
    (plus:SI (match_operand:SI 1 "general_operand"  "%0,  %a")
    (match_operand:SI 2 "general_operand"  "mi???r,id")))]
  ""
  "*
{
  if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
    if(D_REG_P(operands[2])){
      output_asm_insn (\"lslb\\t\\t;addhi: R:%0 += R:%2\", operands);
      return \"rola\\t\\t;also R:%0 *= 2\";
    }
    else {
      output_asm_insn (\"pshs\\t%2\\t;addhi: R:%0 += R:%2\", operands);
      return \"add%0\\t,s++\";
    }
  }

  if (D_REG_P (operands[0])) {
    return \"add%0\\t%2\\t;addhi: R:%0 += %2\";
  }

  if (A_REG_P (operands[0])) {
    if (A_REG_P (operands[1])) {
      if (D_REG_P (operands[2]))
        return \"lea%0\\t%2,%1\\t;addhi: R:%0 = R:%1 + R:%2\";
      else
        return \"lea%0\\t%a2,%1\\t;addhi: R:%0 = R:%1 + %2\";
    }
    else {
      if(D_REG_P (operands[1]))
        return \"lea%0\\t%1,%2\\t;addhi: R:%0 = R:%2 + R:%1\";
      else
        return \"lea%0\\t%a1,%2\\t;addhi: R:%0 = R:%2 + %1\";
    }
  }
  else
    return \".bogus\";
}")

;;-
;;- Courtesy of Ulrich Boetzel
;;-
;; fuer s := s+Memory muss eine Interrupt-sichere Version gefunden werden!!
(define_insn "addhi3"
  [(set (match_operand:HI 0 "register_operand" "=d,  =a, =a, !=a")
    (plus:HI (match_operand:HI 1 "register_operand" "%0,   a,  0, !a")
    (match_operand:HI 2 "general_operand"  "mi!r,id, !m, !a")
  ))]
  ""
  "*
{
  if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
    output_asm_insn (\"pshs\\t%2\\t;addhi: R:%0 += R:%2\", operands);
    return \"add%0\\t,s++\";
  }

  if (D_REG_P (operands[0])) {
    return \"add%0\\t%2\\t;addhi: R:%0 += %2\";
  }

  if(A_REG_P (operands[0])) {
    if (A_REG_P (operands[1])) {
      if (GET_CODE (operands[2]) == MEM) {
        output_asm_insn (\"exg\\td,%0\\t;addhi: R:%0 = R:%1 + %2\", operands);
        output_asm_insn (\"addd\\t%2\", operands);
        return \"exg\\td,%0\";
      }
      else if(D_REG_P (operands[2]))
        return \"lea%0\\t%2,%1\\t;addhi: R:%0 = R:%1 + R:%2\";
      else if(A_REG_P (operands[2])) {
        output_asm_insn (\"pshs\\td\\t;addhi: R:%0 = R:%1 + R:%2\", operands);
        output_asm_insn (\"tfr\\t%1,d\", operands);
        output_asm_insn (\"lea%0\\td,%2\", operands);
        return \"puls\\td\";
      }
      else
        return \"lea%0\\t%a2,%1\\t;addhi: R:%0 = R:%1 + %2\";
    }
    else {
      if(D_REG_P (operands[1]))
        return \"lea%0\\t%1,%2\\t;addhi: R:%0 = R:%2 + R:%1\";
      else
        return \"lea%0\\t%a1,%2\\t;addhi: R:%0 = R:%2 + %1\";
        }
    }
    else
      return \".bogus\";
}")


(define_insn "addqi3"
  [(set (match_operand:QI 0 "byte_operand" "=q,m")
    (plus:QI (match_operand:QI 1 "byte_operand" "%0,0")
    (match_operand:QI 2 "general_operand" "mi,I")))]
  ""
  "*
{
  if ((GET_CODE (operands[0]) == MEM) && (operands[2] == const1_rtx))
    return \"inc\\t%0\\t;addqi: %0 += 1\";

  if (GET_CODE (operands[0]) == REG)
  {
    if (operands[2] == const1_rtx)
      return \"inc%0\\t\\t;addqi: R:%0 += 1\";
    else if (operands[2] == constm1_rtx)
      return \"dec%0\\t\\t;addqi: R:%0 -= 1\";
  }

  return \"add%0\\t%2\\t;addqi: R:%0 += %2\";
}")


;;--------------------------------------------------------------------
;;- Subtract instructions.
;;--------------------------------------------------------------------
(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,a")
    (minus:SI (match_operand:SI 1 "register_operand" "0,0")
    (match_operand:SI 2 "general_operand" "mi?r,i")))]
  ""
  "*
{
  if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
    output_asm_insn (\"pshs\\t%2\\t;subsi: R:%0 -= R:%2\", operands);
    return \"sub%0\\t,s++\";
  }

  if (D_REG_P (operands[0]))
    return \"sub%0\\t%2\\t;subsi: R:%0 -= %2\";
  else
    return \"lea%0\\t%n2,%1\\t;subsi: R:%0 = R:%1 + %n2\";
}")


(define_expand "subgen"
  [(set (match_operand:SI 0 "general_operand" "=g")
    (minus:SI (match_operand:SI 1 "general_operand" "0")
    (match_operand:SI 2 "general_operand" "g")))]
  ""
  "
{
  rtx sum;

  sum = (gen_rtx (PLUS, SImode, operands[1], negate_rtx (SImode, operands[2])));
  emit_insn (gen_rtx (SET, SImode, operands[0], sum));
  DONE;
}")


(define_insn "subhi3"
  [(set (match_operand:HI 0 "register_operand" "=d,a")
    (minus:HI (match_operand:HI 1 "register_operand" "0,0")
    (match_operand:HI 2 "general_operand" "mi?r,i")))]
  ""
  "*
{
  if ((D_REG_P (operands[0])) && (REG_P (operands[2]))) {
    output_asm_insn (\"pshs\\t%2\\t;subhi: R:%0 -= R:%2\", operands);
    return \"sub%0\\t,s++\";
  }
  if (D_REG_P (operands[0])) {
    return \"sub%0\\t%2\\t;subhi: R:%0 -= %2\";
  }
  else
    return \"lea%0\\t%n2,%1\\t;subhi: R:%0 = R:%1 + %n2\";
}")
 

;;*** NOT USED ***;;   ;;-(define_expand "subhgen"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:HI 0 "register_operand" "=d")
;;*** NOT USED ***;;   ;;-	(minus:HI (match_operand:HI 1 "register_operand" "0")
;;*** NOT USED ***;;   ;;-		 (match_operand:HI 2 "address_operand" "min")))]
;;*** NOT USED ***;;   ;;-    ""
;;*** NOT USED ***;;   ;;-    "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    rtx sum;
;;*** NOT USED ***;;   ;;-
;;*** NOT USED ***;;   ;;-    if ((D_REG_P (operands[0])) && (GET_CODE (operands[2]) == MEM)) {
;;*** NOT USED ***;;   ;;-	emit_insn (gen_subq (operands[0], operands[1], operands[2]));
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    else {
;;*** NOT USED ***;;   ;;-	sum = (gen_rtx (PLUS, HImode, operands[1],
;;*** NOT USED ***;;   ;;-	    negate_rtx (HImode, operands[2])));
;;*** NOT USED ***;;   ;;-	emit_insn (gen_rtx (SET, HImode, operands[0], sum));
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    DONE;
;;*** NOT USED ***;;   ;;-}")


(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand" "=q,!q")
    (minus:QI (match_operand:QI 1 "register_operand" "0,min")
    (match_operand:QI 2 "general_operand" "min,0")))]
  ""
  "*
{
  if (which_alternative == 0) {
    if (operands[2] == const1_rtx)
      return \"dec%0\\t\\t;subqi: R:%0 -= 1\";
    else
      return \"sub%0\\t%2\\t;subqi: R:%0 -= %2\";
  }
  else {
    if (operands[1] == const1_rtx)
      output_asm_insn(\"dec%0\\t\\t;subqi: R:%0 = 1 - R:%0\", operands);
    else
      output_asm_insn(\"sub%0\\t%1\\t;subqi: R:%0 = %1 - R:%0\", operands);
    return \"neg%0\";
  }
}")


;;--------------------------------------------------------------------
;;- Multiply instructions.
;;--------------------------------------------------------------------

;;*** NOT USED ***;;   ;;-(define_expand "mulsi3"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:SI 0 "register_operand" "=d")
;;*** NOT USED ***;;   ;;-     (mult:SI (match_operand:SI 1 "register_operand" "0")
;;*** NOT USED ***;;   ;;-     (match_operand:SI 2 "register_operand" "a")))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    emit_insn (gen_call_lib (
;;*** NOT USED ***;;   ;;- gen_rtx (SYMBOL_REF, Pmode, \"mul_si\"),
;;*** NOT USED ***;;   ;;- operands[0], operands[1], operands[2]));
;;*** NOT USED ***;;   ;;-    DONE;
;;*** NOT USED ***;;   ;;-}")

;;*** NOT USED ***;;   ;;-(define_expand "mulhi3"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:HI 0 "register_operand" "=d")
;;*** NOT USED ***;;   ;;-     (mult:HI (match_operand:HI 1 "register_operand" "0")
;;*** NOT USED ***;;   ;;-             (match_operand:HI 2 "register_operand" "a")))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    emit_insn (gen_call_lib_hi (
;;*** NOT USED ***;;   ;;-     gen_rtx (SYMBOL_REF, Pmode, \"mulhi3\"),
;;*** NOT USED ***;;   ;;-     operands[0], operands[1], operands[2]));
;;*** NOT USED ***;;   ;;-    DONE;
;;*** NOT USED ***;;   ;;-}")

(define_insn "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=d")
    (mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "q"))
    (match_operand:QI 2 "general_operand" "K")))
    (clobber (match_dup 1))]
  ""
  "*
{
  output_asm_insn (\"lda\\t%2\\t;mulqihi3: R:%0 = R:%0 * %2\", operands);
  return \"mul\";
}")


(define_insn "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=d")
    (mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "q"))
    (match_operand:QI 2 "general_operand" "K")))
    (clobber (match_dup 1))]
  ""
  "*
{
  output_asm_insn (\"lda\\t%2\\t;umulqihi3: R:%0 = R:%0 * %2\", operands);
  return \"mul\";
}")



;;-
;;- Courtesy of Ulrich Boetzel

;;-
;;- Courtesy of Ulrich Boetzel
;;- 1 Pushbefehl, da mult. kommutativ
;;- 
(define_insn "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=d,d")
    (mult:HI (match_operand:HI 1 "register_operand" "r,d")
    (match_operand:HI 2 "general_operand" "r,mi")))]
  ""
  "*
{
  if ((GET_CODE (operands[2]) == CONST_INT) && (INTVAL (operands[2]) <= 0xFF))
  {
    output_asm_insn (\"lda\\t%2\\t;mulhi3: R:%0 = R:%0 * %2\", operands);
    return \"mul\";
  }
  else
  {
    output_asm_insn (\"pshs\\t%1,%2\\t; sichern Operanden R:%1,R:%2\", operands);
    output_asm_insn (\"jsr\\t_mulhi3\\t; Aufruf mulhi, Ergebnis in D\", operands);
    return \"leas\\t4,s\\t; Aufraeumen Stack\";
  }
}")



;;--------------------------------------------------------------------
;;- Divide instructions.
;;--------------------------------------------------------------------

;;*** NOT USED ***;;   ;;-(define_expand "divsi3"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:SI 0 "data_reg_operand" "=d")
;;*** NOT USED ***;;   ;;- (div:SI (match_operand:SI 1 "data_reg_operand" "0")
;;*** NOT USED ***;;   ;;- (match_operand:SI 2 "register_operand" "a")))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    emit_insn (gen_call_lib (
;;*** NOT USED ***;;   ;;- gen_rtx (SYMBOL_REF, Pmode, \"divsi3\"),
;;*** NOT USED ***;;   ;;- operands[0], operands[1], operands[2]));
;;*** NOT USED ***;;   ;;-    DONE;
;;*** NOT USED ***;;   ;;-}")

(define_expand "divhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
    (div:HI (match_operand:HI 1 "data_reg_operand" "0")
    (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
  emit_insn (gen_call_lib_hi (
    gen_rtx (SYMBOL_REF, Pmode, \"divhi3\"), 
    operands[0], operands[1], operands[2]));
  DONE;
}")


(define_expand "divqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q,g")
    (div:QI (match_operand:QI 1 "byte_reg_operand" "0,0")
    (match_operand:QI 2 "byte_operand" "qm,g")))]
  ""
  "
{
  emit_insn (gen_call_lib_qi (
    gen_rtx (SYMBOL_REF, Pmode, \"divqi3\"),
    operands[0], operands[1], operands[2]));
  DONE;
}")


(define_expand "udivhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
     (udiv:HI (match_operand:HI 1 "data_reg_operand" "0")
              (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
  emit_insn (gen_call_lib_hi (
    gen_rtx (SYMBOL_REF, Pmode, \"udivhi3\"),
    operands[0], operands[1], operands[2]));
  DONE;
}")


;;--------------------------------------------------------------------
;;- mod
;;--------------------------------------------------------------------

;;*** NOT USED ***;;   ;;-(define_expand "modsi3"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:SI 0 "data_reg_operand" "=d")
;;*** NOT USED ***;;   ;;- (mod:SI (match_operand:SI 1 "data_reg_operand" "0")
;;*** NOT USED ***;;   ;;-  (match_operand:SI 2 "register_operand" "a")))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    emit_insn (gen_call_lib (
;;*** NOT USED ***;;   ;;- gen_rtx (SYMBOL_REF, Pmode, \"mod_si\"),
;;*** NOT USED ***;;   ;;- operands[0], operands[1], operands[2]));
;;*** NOT USED ***;;   ;;-    DONE;
;;*** NOT USED ***;;   ;;-}")

(define_expand "modhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
    (mod:HI (match_operand:HI 1 "data_reg_operand" "0")
    (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
  emit_insn (gen_call_lib_hi (
    gen_rtx (SYMBOL_REF, Pmode, \"modhi3\"),
    operands[0], operands[1], operands[2]));
  DONE;
}")


(define_expand "modqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
    (mod:QI (match_operand:QI 1 "byte_reg_operand" "0")
    (match_operand:QI 2 "byte_operand" "g")))]
  ""
  "
{
  emit_insn (gen_call_lib_qi (
    gen_rtx (SYMBOL_REF, Pmode, \"modqi3\"),
    operands[0], operands[1], operands[2]));
  DONE;
}")


(define_expand "umodhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
    (umod:HI (match_operand:HI 1 "data_reg_operand" "0")
    (match_operand:HI 2 "register_operand" "a")))]
  ""
  "
{
  emit_insn (gen_call_lib_hi (
    gen_rtx (SYMBOL_REF, Pmode, \"umodhi3\"),
    operands[0], operands[1], operands[2]));
  DONE;
}")



;;--------------------------------------------------------------------
;;- and, or, xor
;;--------------------------------------------------------------------

(define_insn "andsi3"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
    (and:SI (match_operand:SI 1 "data_reg_operand" "%0")
    (match_operand:SI 2 "address_operand" "min")))]
  ""
  "*
{
  int n;
  rtx xoperands[4];

  if (GET_CODE (operands[2]) == CONST_INT) {
    xoperands[0] = operands[0];
    xoperands[1] = operands[1];
    xoperands[3] = operands[2];

    xoperands[2] = gen_rtx (CONST_INT, SImode, (INTVAL (operands[2]) >> 8) & 0xff);
    output_asm_insn (\"anda\\t%2\\t;andsi: R:%0 AND %3\", xoperands);

    xoperands[2] = gen_rtx (CONST_INT, SImode, INTVAL (operands[2]) & 0xff);
    output_asm_insn (\"andb\\t%2\", xoperands);
  }
  else {
    output_asm_insn (\"anda\\t%2\\t;andsi: R:%0 AND %2\", operands);
    output_asm_insn (\"andb\\t%L2\", operands);
  }
  return \"\";
}")


(define_insn "andhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
    (and:HI (match_operand:HI 1 "data_reg_operand" "%0")
    (match_operand:HI 2 "general_operand" "min")))]
  ""
  "*
{
  int n;
  rtx xoperands[4];

  if (GET_CODE (operands[2]) == CONST_INT) {
    xoperands[0] = operands[0];
    xoperands[1] = operands[1];
    xoperands[3] = operands[2];

    xoperands[2] = gen_rtx (CONST_INT, HImode, (INTVAL (operands[2]) >> 8) & 0xff);
    output_asm_insn (\"anda\\t%2\\t;andhi: R:%0 AND %3\", xoperands);

    xoperands[2] = gen_rtx (CONST_INT, HImode, INTVAL (operands[2]) & 0xff);
    output_asm_insn (\"andb\\t%2\", xoperands);
  }
  else {
    output_asm_insn (\"anda\\t%2\\t;andhi: R:%0 AND %2\", operands);
    output_asm_insn (\"andb\\t%L2\", operands);
  }
  return \"\";
}")


(define_insn "andqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
    (and:QI (match_operand:QI 1 "byte_reg_operand" "%0")
    (match_operand:QI 2 "general_operand" "min")))]
  ""
  "and%0\\t%2\\t;andqi: R:%0 &= %2")


;;--------------------------------------------------------------------
;;- Bit set instructions.
;;--------------------------------------------------------------------

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
    (ior:SI (match_operand:SI 1 "data_reg_operand" "%0")
    (match_operand:SI 2 "address_operand" "min")))]
  ""
  "*
{
  int n;
  rtx xoperands[3];

  if (GET_CODE (operands[2]) == CONST_INT) {
    xoperands[0] = operands[0];
    xoperands[1] = operands[1];

    xoperands[2] = gen_rtx (CONST_INT, SImode, (INTVAL (operands[2]) >> 8) & 0xff);
    output_asm_insn (\"ora\\t%2\\t;iorsi: %0 OR %2\", xoperands);

    xoperands[2] = gen_rtx (CONST_INT, SImode, INTVAL (operands[2]) & 0xff);
    output_asm_insn (\"orb\\t%2\", xoperands);
  }
  else {
    output_asm_insn (\"ora\\t%2\\t;iorsi: %0 OR %2\", operands);
    output_asm_insn (\"orb\\t%L2\", operands);
  }
  return \"\";
}")


(define_insn "iorhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
    (ior:HI (match_operand:HI 1 "data_reg_operand" "%0")
    (match_operand:HI 2 "general_operand" "min")))]
  ""
  "*
{
  int n;
  rtx xoperands[3];

  if (GET_CODE (operands[2]) == CONST_INT) {
    xoperands[0] = operands[0];
    xoperands[1] = operands[1];

    xoperands[2] = gen_rtx (CONST_INT, HImode, (INTVAL (operands[2]) >> 8) & 0xff);
    output_asm_insn (\"ora\\t%2\\t;iorhi: %0 OR %2\", xoperands);

    xoperands[2] = gen_rtx (CONST_INT, HImode, INTVAL (operands[2]) & 0xff);
    output_asm_insn (\"orb\\t%2\", xoperands);
  }
  else {
    output_asm_insn (\"ora\\t%2\\t;iorhi: %0 OR %2\", operands);
    output_asm_insn (\"orb\\t%L2\", operands);
  }
  return \"\";
}")


(define_insn "iorqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
    (ior:QI (match_operand:QI 1 "byte_reg_operand" "%0")
    (match_operand:QI 2 "general_operand" "min")))]
  ""
  "or%0\\t%2\\t;iorqi: %0 |= %2 ")

;;--------------------------------------------------------------------
;;- xor instructions.
;;--------------------------------------------------------------------

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
    (xor:SI (match_operand:SI 1 "data_reg_operand" "%0")
    (match_operand:SI 2 "address_operand" "min")))]
  ""
  "*
{
  int n;
  rtx xoperands[3];

  if (GET_CODE (operands[2]) == CONST_INT) {
    xoperands[0] = operands[0];
    xoperands[1] = operands[1];

    xoperands[2] = gen_rtx (CONST_INT, SImode, (INTVAL (operands[2]) >> 8) & 0xff);
    output_asm_insn (\"eora\\t%2\\t;xorsi: %0 XOR %2\", xoperands);

    xoperands[2] = gen_rtx (CONST_INT, SImode, INTVAL (operands[2]) & 0xff);
    output_asm_insn (\"eorb\\t%2\", xoperands);
  }
  else {
    output_asm_insn (\"eora\\t%2\\t;xorsi: %0 XOR %2\", operands);
    output_asm_insn (\"eorb\\t%L2\", operands);
  }
  return \"\";
}")


(define_insn "xorhi3"
  [(set (match_operand:HI 0 "data_reg_operand" "=d")
    (xor:HI (match_operand:HI 1 "data_reg_operand" "%0")
    (match_operand:HI 2 "address_operand" "min")))]
  ""
  "*
{
  int n;
  rtx xoperands[3];

  if (GET_CODE (operands[2]) == CONST_INT) {
    xoperands[0] = operands[0];
    xoperands[1] = operands[1];

    xoperands[2] = gen_rtx (CONST_INT, HImode, (INTVAL (operands[2]) >> 8) & 0xff);
    output_asm_insn (\"eora\\t%2\\t;xorhi: %0 XOR %2\", xoperands);

    xoperands[2] = gen_rtx (CONST_INT, HImode, INTVAL (operands[2]) & 0xff);
    output_asm_insn (\"eorb\\t%2\", xoperands);
  }
  else {
    output_asm_insn (\"eora\\t%2\\t;xorhi: %0 XOR %2\", operands);
    output_asm_insn (\"eorb\\t%L2\", operands);
  }
  return \"\";
}")

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
    (xor:QI (match_operand:QI 1 "byte_reg_operand" "%0")
    (match_operand:QI 2 "byte_operand" "mK")))]
  ""
  "eor%0\\t%2\\t;xorqi: %0 $= %2 ")


;;--------------------------------------------------------------------
;;-  Two's Complements
;;--------------------------------------------------------------------

(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=d,a")
    (neg:SI (match_operand:SI 1 "register_operand" "0,0")))]
  ""
  "*
{
  if (D_REG_P (operands[0])) {
    return \"coma\\t\\t;negsi: R:%0\;comb\;addd\\t#1\";
  }
  else if (A_REG_P (operands[0])) {
    output_asm_insn (\"exg\\td,%0\\t;negsi: R:%0 = -(R:%0)\", operands);
    return \"coma\;comb\;addd\\t#1\;exg\\td,%0\";
  }
  else {
    output_asm_insn (\"com\\t%0\\t;negsi: %0\;com\\t%L0\", operands);
    output_asm_insn (\"inc\\t%L0\", operands);
    output_asm_insn (\"bne\\t%l0\", operands);
    output_asm_insn (\"inc\\t%0\", operands);
    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LI\",
      CODE_LABEL_NUMBER (operands[0]));
    return \"\";
  }
}")

(define_insn "neghi2"
  [(set (match_operand:HI 0 "general_operand" "=d,a")
    (neg:HI (match_operand:HI 1 "general_operand" "0,0")))]
  ""
  "*
{
  if (D_REG_P (operands[0])) {
    return \"coma\\t\\t;neghi: R:%0\;comb\;addd\\t#1\";
  }
  else if (A_REG_P (operands[0])) {
    output_asm_insn (\"exg\\td,%0\\t;neghi: R:%0 = -(R:%0)\", operands);
    return \"coma\;comb\;addd\\t#1\;exg\\td,%0\";
  }
  else {
    output_asm_insn (\"com\\t%0\\t;neghi: %0\;com\\t%L0\", operands);
    output_asm_insn (\"inc\\t%L0\", operands);
    output_asm_insn (\"bne\\t%l0\", operands);
    output_asm_insn (\"inc\\t%0\", operands);
    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LI\",
      CODE_LABEL_NUMBER (operands[0]));
    return \"\";
  }
}")

(define_insn "negqi2"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
    (neg:QI (match_operand:QI 1 "byte_operand" "0")))]
  ""
  "*
{
  if (REG_P (operands[0]))
    return \"neg%0\\t\\t;negqi: R:%0\";
  else
    return \"neg\\t%0\\t;negqi: %0\";
}")

;;--------------------------------------------------------------------
;;-  One's Complements
;;--------------------------------------------------------------------

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "data_reg_operand" "=d")
    (not:SI (match_operand:SI 1 "data_reg_operand" "0")))]
  ""
  "coma\\t\\t;one_cmplsi:\;comb")

(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "general_operand" "=d")
    (not:HI (match_operand:HI 1 "general_operand" "0")))]
  ""
  "*
{
  if (REG_P (operands[0]))
    return \"coma\\t\\t;comhi: R:%0\;comb\";
  else
    return \"com\\t%0\\t;comhi: %0\;com\\t%L0\";
}")

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
    (not:QI (match_operand:QI 1 "byte_operand" "0")))]
  ""
  "*
{
  if (REG_P (operands[0]))
    return \"com%0\\t\\t;comqi: R:%0\";
  else
    return \"com\\t%0\\t;comqi: %0\";
}")

;;--------------------------------------------------------------------
;;- arithmetic shifts
;;--------------------------------------------------------------------
;;

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm,d")
    (ashift:SI (match_operand:SI 1 "general_operand" "0,0")
    (match_operand:SI 2 "nonmemory_operand" "nI,a")))
    (clobber (match_dup 2))]
  ""
  "*
{
  int n;
  output_asm_insn (\"\\t\\t;ashlsi: %0 by %2\", operands);

  if (GET_CODE (operands[2]) == CONST_INT) {
    n = INTVAL (operands[2]) & 0x0f;
    while (n-- > 0) {
      if (D_REG_P (operands[0]))
        output_asm_insn (\"aslb\;rola\", operands);
      else
        output_asm_insn (\"asl\\t%L0\;rol\\t%0\", operands);
    }
  }

  else {
    output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
    output_asm_insn (\"cmp%2\\t-1\", operands);
    output_asm_insn (\"bmi .+9\", operands);
    output_asm_insn (\"aslb\;rola\", operands);
    output_asm_insn (\"bra .-9\\t;loop\", operands);
  }
  return \"\";
}")

(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm,d")
    (ashift:HI (match_operand:HI 1 "general_operand" "0,0")
    (match_operand:HI 2 "nonmemory_operand" "nI,a")))
    (clobber (match_dup  2))]
  ""
  "*
{
  int n;
 
  output_asm_insn (\"\\t\\t;ashlhi: %0 by %2\", operands);
  if (GET_CODE (operands[2]) == CONST_INT) {
    n = INTVAL (operands[2]) & 0x0f;
    while (n-- > 0) {
      if (D_REG_P (operands[0]))
        output_asm_insn (\"aslb\;rola\", operands);
      else
        output_asm_insn (\"asl\\t%L0\;rol\\t%0\", operands);
    }
  }
  else {
    output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
    output_asm_insn (\"cmp%2\\t-1\", operands);
    output_asm_insn (\"bmi .+9\", operands);
    output_asm_insn (\"aslb\;rola\", operands);
    output_asm_insn (\"bra .-9\\t;loop\", operands);
  }
  return \"\";
}")


(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "byte_reg_operand" "=q")
    (ashift:QI (match_operand:QI 1 "byte_reg_operand" "0")
    (match_operand:QI 2 "nonmemory_operand" "nI")))]
  ""
  "*
{
  int n;

  n = INTVAL (operands[2]) & 0x07;
  output_asm_insn (\"\\t\\t;ashlqi: %0 by %2\", operands);
  while (n-- > 0) {
    if (REG_P (operands[0]))
      output_asm_insn (\"asl%0\", operands);
    else
      output_asm_insn (\"asl\\t%0\", operands);
  }
  return \"\";
}")


(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm,d")
    (ashiftrt:SI (match_operand:SI 1 "general_operand" "0,0")
    (match_operand:SI 2 "nonmemory_operand" "nI,a")))
    (clobber (match_dup  2))]
  ""
  "*
{
  int n;

  output_asm_insn (\"\\t\\t;ashrsi: %0 by %2\", operands);
  if (GET_CODE (operands[2]) == CONST_INT) {
    n = INTVAL (operands[2]) & 0x0f;
    while (n-- > 0) {
      if (D_REG_P (operands[0]))
        output_asm_insn (\"asra\;rorb\", operands);
      else
        output_asm_insn (\"asr\\t%0\;ror\\t%L0\", operands);
    }
  }
  else {
    output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
    output_asm_insn (\"cmp%2\\t-1\", operands);
    output_asm_insn (\"bmi .+9\", operands);
    output_asm_insn (\"asra\;rorb\", operands);
    output_asm_insn (\"bra .-9\\t;loop\", operands);
  }
  return \"\";
}")

(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm,d")
    (ashiftrt:HI (match_operand:HI 1 "general_operand" "0,0")
    (match_operand:HI 2 "nonmemory_operand" "nI,a")))
    (clobber (match_dup  2))]
  ""
  "*
{
  int n;
 
  output_asm_insn (\"\\t\\t;ashrhi: %0 by %2\", operands);
  if (GET_CODE (operands[2]) == CONST_INT) {
    n = INTVAL (operands[2]) & 0x0f;
    while (n-- > 0) {
      if (D_REG_P (operands[0]))
        output_asm_insn (\"asra\;rorb\", operands);
      else
        output_asm_insn (\"asr\\t%0\;ror\\t%L0\", operands);
      }
  }
  else {
    output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
    output_asm_insn (\"cmp%2\\t-1\", operands);
    output_asm_insn (\"bmi .+9\", operands);
    output_asm_insn (\"asra\;rorb\", operands);
    output_asm_insn (\"bra .-9\\t;loop\", operands);
  }
  return \"\";
}")


(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
    (ashiftrt:QI (match_operand:QI 1 "general_operand" "0")
    (match_operand:QI 2 "nonmemory_operand" "rnI")))
  ]
  ""
  "*
{
  int n;

  n = INTVAL (operands[2]) & 0x07;
  output_asm_insn (\"\\t\\t;ashrqi: %0 by %2\", operands);
  while (n-- > 0) {
    if (Q_REG_P (operands[0]))
      output_asm_insn (\"asr%0\", operands);
    else
      output_asm_insn (\"asr\\t%0\", operands);
  }
  return \"\";
}")

;;--------------------------------------------------------------------
;; logical shift instructions
;;--------------------------------------------------------------------

;;*** NOT USED ***;;   ;;-(define_insn "lshlsi3"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:SI 0 "general_operand" "=dm,d")
;;*** NOT USED ***;;   ;;-	(lshift:SI (match_operand:SI 1 "general_operand" "0,0")
;;*** NOT USED ***;;   ;;-	     (match_operand:SI 2 "nonmemory_operand" "nI,a")))
;;*** NOT USED ***;;   ;;-   (clobber (match_dup  2))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "*
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    int n;
;;*** NOT USED ***;;   ;;-
;;*** NOT USED ***;;   ;;-    output_asm_insn (\"\\t\\t;lshlsi: %0 by %2\", operands);
;;*** NOT USED ***;;   ;;-    if (GET_CODE (operands[2]) == CONST_INT) {
;;*** NOT USED ***;;   ;;-	n = INTVAL (operands[2]) & 0x0f;
;;*** NOT USED ***;;   ;;-	while (n-- > 0) {
;;*** NOT USED ***;;   ;;-	    if (D_REG_P (operands[0]))
;;*** NOT USED ***;;   ;;-		output_asm_insn (\"lslb\;rola\", operands);
;;*** NOT USED ***;;   ;;-	    else
;;*** NOT USED ***;;   ;;-		output_asm_insn (\"lsl\\t%L0\;rol\\t%0\", operands);
;;*** NOT USED ***;;   ;;-	}
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    else {
;;*** NOT USED ***;;   ;;-	output_asm_insn (\"lslb\;rola\", operands);
;;*** NOT USED ***;;   ;;-	output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
;;*** NOT USED ***;;   ;;-	output_asm_insn (\"bne .-4\\t;loop\", operands);
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    return \"\";
;;*** NOT USED ***;;   ;;-}")

;;*** NOT USED ***;;   ;;-(define_insn "lshlhi3"
;;*** NOT USED ***;;   ;;-  [(set (match_operand:HI 0 "general_operand" "=dm,d")
;;*** NOT USED ***;;   ;;-        (lshift:HI (match_operand:HI 1 "general_operand" "0,0")
;;*** NOT USED ***;;   ;;-             (match_operand:HI 2 "nonmemory_operand" "nI,a")))
;;*** NOT USED ***;;   ;;-   (clobber (match_dup  2))]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "*
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-    int n;
;;*** NOT USED ***;;   ;;- 
;;*** NOT USED ***;;   ;;-    output_asm_insn (\"\\t\\t;lshlhi: %0 by %2\", operands);
;;*** NOT USED ***;;   ;;-    if (GET_CODE (operands[2]) == CONST_INT) {
;;*** NOT USED ***;;   ;;-        n = INTVAL (operands[2]) & 0x0f;
;;*** NOT USED ***;;   ;;-        while (n-- > 0) {
;;*** NOT USED ***;;   ;;-            if (D_REG_P (operands[0]))
;;*** NOT USED ***;;   ;;-                output_asm_insn (\"lslb\;rola\", operands);
;;*** NOT USED ***;;   ;;-            else
;;*** NOT USED ***;;   ;;-                output_asm_insn (\"lsl\\t%L0\;rol\\t%0\", operands);
;;*** NOT USED ***;;   ;;-        }
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    else {
;;*** NOT USED ***;;   ;;-        output_asm_insn (\"lslb\;rola\", operands);
;;*** NOT USED ***;;   ;;-        output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
;;*** NOT USED ***;;   ;;-        output_asm_insn (\"bne .-4\\t;loop\", operands);
;;*** NOT USED ***;;   ;;-    }
;;*** NOT USED ***;;   ;;-    return \"\";
;;*** NOT USED ***;;   ;;-}")


(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "general_operand" "=qm")
    (lshiftrt:QI (match_operand:QI 1 "general_operand" "0")
    (match_operand:SI 2 "general_operand" "i")))
    (clobber (match_dup  2))]
  ""
  "*
{
  int n;

  output_asm_insn (\"\\t\\t;lshrqi: %0 by %2\", operands);
  n = INTVAL (operands[2]) & 0x0f;

  if (n >= 8)
  {
    output_asm_insn (\"clr%0\", operands);
  }
  else
  {
    while (n-- > 0) {
      if (REG_P (operands[0]))
        output_asm_insn (\"lsr%0\", operands);
      else
        output_asm_insn (\"lsr\\t%0\", operands);
    }
  }
  return \"\";
}")


(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm,d")
    (lshiftrt:SI (match_operand:SI 1 "general_operand" "0,0")
    (match_operand:SI 2 "nonmemory_operand" "rnI,a")))
    (clobber (match_dup  2))]
  ""
  "*
{
  int n;

  output_asm_insn (\"\\t\\t;lshrsi: %0 by %2\", operands);
  if (GET_CODE (operands[2]) == CONST_INT) {
    n = INTVAL (operands[2]) & 0x0f;

    if ((n >= 8) && D_REG_P (operands[0]))
    {
      output_asm_insn (\"tfr a,b\;clra\", operands);
      n -= 8;
    }

    while (n-- > 0) {
      if (D_REG_P (operands[0]))
        output_asm_insn (\"lsra\;rorb\", operands);
      else
        output_asm_insn (\"lsr\\t%0\;ror\\t%L0\", operands);
    }
  }

  else {
    output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
    output_asm_insn (\"cmp%2\\t-1\", operands);
    output_asm_insn (\"bmi .+9\", operands);
    output_asm_insn (\"lsra\;rorb\", operands);
    output_asm_insn (\"bra .-9\\t;loop\", operands);
  }

  return \"\";
}")

(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm,d")
    (lshiftrt:HI (match_operand:HI 1 "general_operand" "0,0")
    (match_operand:HI 2 "nonmemory_operand" "rnI,a")))
    (clobber (match_dup  2))]
  ""
  "*
{
  int n;
 
  output_asm_insn (\"\\t\\t;lshrhi: %0 by %2\", operands);

  if (GET_CODE (operands[2]) == CONST_INT) {
    n = INTVAL (operands[2]) & 0x0f;

    if ((n >= 8) && D_REG_P (operands[0]))
    {
      output_asm_insn (\"tfr a,b\;clra\", operands);
      n -= 8;
    }

    while (n-- > 0) {
      if (D_REG_P (operands[0]))
        output_asm_insn (\"lsra\;rorb\", operands);
      else
        output_asm_insn (\"lsr\\t%0\;ror\\t%L0\", operands);
    }
  }

  else {
    output_asm_insn (\"lea%2\\t-1,%2\\t;decr shift count\", operands);
    output_asm_insn (\"cmp%2\\t-1\", operands);
    output_asm_insn (\"bmi .+9\", operands);
    output_asm_insn (\"lsra\;rorb\", operands);
    output_asm_insn (\"bra .-9\\t;loop\", operands);
  }
 
  return \"\";
}")


;;--------------------------------------------------------------------
;; rotate instructions
;;--------------------------------------------------------------------

(define_insn "rotlsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm")
    (rotate:SI (match_operand:SI 1 "general_operand" "0")
    (match_operand:SI 2 "nonmemory_operand" "rnI")))]
  ""
  "rol.w %2,%0")

(define_insn "rotlhi3"
  [(set (match_operand:HI 0 "general_operand" "=dm")
    (rotate:HI (match_operand:HI 1 "general_operand" "0")
    (match_operand:HI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
  int n; 

  n = INTVAL (operands[2]) & 0x07;
  output_asm_insn (\"\\t\\t;rotlhi: %0 by %2\", operands);

  while (n-- > 0) {
    if (Q_REG_P (operands[0]))
      output_asm_insn (\"rol%0\", operands);
    else
      output_asm_insn (\"rol\\t%0\", operands);
  }
  return \"\";
}")

(define_insn "rotlqi3"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
    (rotate:QI (match_operand:QI 1 "byte_operand" "0")
    (match_operand:HI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
  int n;
 
  n = INTVAL (operands[2]) & 0x07;
  output_asm_insn (\"\\t\\t;rotlqi: %0 by %2\", operands);

  while (n-- > 0) {
  if (Q_REG_P (operands[0]))
    output_asm_insn (\"rol%0\", operands);
  else
    output_asm_insn (\"rol\\t%0\", operands);
  }
  return \"\";
}")


(define_insn "rotrsi3"
  [(set (match_operand:SI 0 "general_operand" "=dm")
    (rotatert:SI (match_operand:SI 1 "general_operand" "0")
    (match_operand:SI 2 "nonmemory_operand" "rnI")))]
  ""
  "ror.w %2,%0")

(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "byte_operand" "=dm")
    (rotatert:HI (match_operand:HI 1 "byte_operand" "0")
    (match_operand:HI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
  int n;

  n = INTVAL (operands[2]) & 0x07;
  output_asm_insn (\"\\t\\t;rotrhi: %0 by %2\", operands);

  while (n-- > 0) {
  if (Q_REG_P (operands[0]))
    output_asm_insn (\"ror%0\", operands);
  else
    output_asm_insn (\"ror\\t%0\", operands);
  }
  return \"\";
}")

(define_insn "rotrqi3"
  [(set (match_operand:QI 0 "byte_operand" "=qm")
    (rotatert:QI (match_operand:QI 1 "byte_operand" "0")
    (match_operand:QI 2 "nonmemory_operand" "rnI")))]
  ""
  "*
{
  int n;
 
  n = INTVAL (operands[2]) & 0x07;
  output_asm_insn (\"\\t\\t;rotrqi: %0 by %2\", operands);

  while (n-- > 0) {
    if (Q_REG_P (operands[0]))
      output_asm_insn (\"ror%0\", operands);
    else
      output_asm_insn (\"ror\\t%0\", operands);
  }
  return \"\";
}")

;;--------------------------------------------------------------------
;;-  Jumps and transfers
;;--------------------------------------------------------------------

;;*** NOT USED ***;;   ;;-(define_expand "tablejump"
;;*** NOT USED ***;;   ;;-  [(parallel [(set (pc) (match_operand 0 "" ""))
;;*** NOT USED ***;;   ;;-              (use (label_ref (match_operand 1 "" "")))])]
;;*** NOT USED ***;;   ;;-  ""
;;*** NOT USED ***;;   ;;-  "
;;*** NOT USED ***;;   ;;-{
;;*** NOT USED ***;;   ;;-#ifdef CASE_VECTOR_PC_RELATIVE
;;*** NOT USED ***;;   ;;-    operands[0] = gen_rtx (PLUS, HImode, pc_rtx,
;;*** NOT USED ***;;   ;;-                           gen_rtx (SIGN_EXTEND, HImode, operands[0]));
;;*** NOT USED ***;;   ;;-#endif
;;*** NOT USED ***;;   ;;-}")


;;--------------------------------------------------------------------
;;-  Table jump
;;--------------------------------------------------------------------
;; Operand 0 is the address of the table element to use
;; operand 1 is the CODE_LABEL for the table
;;--------------------------------------------------------------------
(define_insn "tablejump"
  [(parallel [
    (set (pc) (match_operand:HI 0 "general_operand" "g"))
    (use (label_ref (match_operand 1 "" "")))])]
  ""
  "*
{
  if (A_REG_P (operands[0]))
    return \"jmp\\t,%0\\t;V1 tablejump R:%0 (table %1)\";
  else if (D_REG_P (operands[0]))
    return \"pshs %0\;jmp\\t[,s++]\\t;V2 tablejump R:%0 (table %1)\";
  else
    return \"jmp\\t[%0]\\t;V3 tablejump %0 (table %1)\";
}")


(define_insn "indirect_jumpSI"
  [(set (pc) 
    (match_operand:SI 0 "address_operand" "p"))
;;  (use (label_ref (match_operand 1 "" "")))
  ]
  ""
  "*
{
  output_asm_insn (\"jmp\\t%l0\", operands);
  return \"\";
}")


(define_insn "indirect_jump"
  [(set (pc)
    (match_operand:HI 0 "address_operand" "p"))
;;  (use (label_ref (match_operand 1 "" "")))
  ]
  ""
  "*
{
  output_asm_insn (\"jmp\\t%l0\", operands);
  return \"\";
}")


(define_insn "jump"
  [(set (pc)
  (label_ref (match_operand 0 "" "")))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bra\\t%l0\", operands);
  else
    output_asm_insn (\"jmp\\t%l0\", operands);
    return \"\";
}")

(define_insn "beq"
  [(set (pc)
    (if_then_else (eq (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"beq\\t%l0\", operands);
  else
    output_asm_insn (\"lbeq\\t%l0\", operands);
  return \"\";
}")

(define_insn "bne"
  [(set (pc)
    (if_then_else (ne (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bne\\t%l0\", operands);
  else
    output_asm_insn (\"lbne\\t%l0\", operands);
  return \"\";
}")

(define_insn "bgt"
  [(set (pc)
    (if_then_else (gt (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bgt\\t%l0\", operands);
  else
    output_asm_insn (\"lbgt\\t%l0\", operands);
  return \"\";
}")

(define_insn "bgtu"
  [(set (pc)
    (if_then_else (gtu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bhi\\t%l0\", operands);
  else
    output_asm_insn (\"lbhi\\t%l0\", operands);
  return \"\";
}")

(define_insn "blt"
  [(set (pc)
    (if_then_else (lt (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"blt\\t%l0\", operands);
  else
    output_asm_insn (\"lblt\\t%l0\", operands);
  return \"\";
}")

(define_insn "bltu"
  [(set (pc)
    (if_then_else (ltu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"blo\\t%l0\", operands);
  else
    output_asm_insn (\"lblo\\t%l0\", operands);
  return \"\";
}")

(define_insn "bge"
  [(set (pc)
    (if_then_else (ge (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bge\\t%l0\", operands);
  else
    output_asm_insn (\"lbge\\t%l0\", operands);
  return \"\";
}")

(define_insn "bgeu"
  [(set (pc)
    (if_then_else (geu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bhs\\t%l0\", operands);
  else
    output_asm_insn (\"lbhs\\t%l0\", operands);
  return \"\";
}")

(define_insn "ble"
  [(set (pc)
    (if_then_else (le (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"ble\\t%l0\", operands);
  else
    output_asm_insn (\"lble\\t%l0\", operands);
  return \"\";
}")

(define_insn "bleu"
  [(set (pc)
    (if_then_else (leu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" ""))
      (pc)))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bls\\t%l0\", operands);
  else
    output_asm_insn (\"lbls\\t%l0\", operands);
  return \"\";
}")

;;--------------------------------------------------------------------
;;- Negative test and branch
;;--------------------------------------------------------------------
(define_insn ""
  [(set (pc)
    (if_then_else (eq (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bne\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbne\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (ne (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"beq\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbeq\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (gt (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"ble\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lble\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (gtu (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bls\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbls\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (lt (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bge\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbge\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (ltu (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bhs\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbhs\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (ge (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"blt\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lblt\\t%l0\\t;rev\", operands);
    return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (geu (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"blo\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lblo\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (le (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bgt\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbgt\\t%l0\\t;rev\", operands);
  return \"\";
}")

(define_insn ""
  [(set (pc)
    (if_then_else (leu (cc0) (const_int 0))
      (pc)
      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (TARGET_SHORT_BRANCH)
    output_asm_insn (\"bhi\\t%l0\\t;rev\", operands);
  else
    output_asm_insn (\"lbhi\\t%l0\\t;rev\", operands);
  return \"\";
}")

;;--------------------------------------------------------------------
;;-  Calls
;;--------------------------------------------------------------------
;;
;; arg count word may be omitted to save a push and let gcc try to
;; combine the arg list pop.  RETURN_POPS_ARGS from tm.h decides this.

;;- Call a function that returns no value.
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "g")
    (match_operand:SI 1 "general_operand" "g"))]
  ""
  "*
{
  return \"jsr\\t%0\\t;CALL: (VOIDmode) %0 (%a1 bytes)\";
}")

(define_insn "call_value"
  [(set (match_operand 0 "" "=g")
    (call (match_operand:HI 1 "general_operand" "g")
    (match_operand:SI 2 "general_operand" "g")))]
  ""
  "*
  return \"jsr\\t%1\\t;CALL: R:%0 = %1 (%a2 bytes)\";
  ")

;;- return insn not needed -- tej
;;(define_insn "return"
;;  [(return)]
;;  ""
;;  "rts")
;;


;;--------------------------------------------------------------------
;;-  Library call
;;--------------------------------------------------------------------
;; Produce a variant of the `call' insns that is used to call a
;; library routine.
;;
;; Operands are as follows:
;;	0 -- name of function (as SYMBOL_REF)
;;	1 -- output argument
;;	2 -- first input argument
;;	3 -- second input argument
;;--------------------------------------------------------------------
;;
;; The pattern given below just exists to show that we have 3 operands.
(define_expand "call_lib"
 [ (use (match_operand 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
 ""
 "
{
  emit_library_call (operands[0], 0, SImode,
    2, operands[2], SImode, operands[3], SImode);

  /*** assume library function returns value in R0 ***/
  emit_move_insn (operands[1], gen_rtx (REG, SImode, 0));
  DONE;
}")

(define_expand "call_lib_hi"
 [ (use (match_operand 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
 ""
 "
{
    emit_library_call (operands[0], 0, HImode,
        2, operands[2], HImode, operands[3], HImode);

    /*** assume library function returns value in R0 ***/
    emit_move_insn (operands[1], gen_rtx (REG, HImode, 0));
    DONE;
}")

(define_expand "call_lib_qi"
 [ (use (match_operand 0 "" ""))
   (use (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))
   (use (match_operand 3 "" ""))]
 ""
 "
{
    emit_library_call (operands[0], 0, QImode,
        2, operands[2], QImode, operands[3], QImode);

    /*** assume library function returns value in R0 ***/
    emit_move_insn (operands[1], gen_rtx (REG, QImode, 0));
    DONE;
}")

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")
    

;;--------------------------------------------------------------------
;;- Peepholes
;;- TBD
;;--------------------------------------------------------------------

;; Optimize the case of following a register load with a test
;; of reg just moved.

(define_peephole
  [(set (match_operand:SI 0 "register_operand" "=r")
    (match_operand:SI 1 "memory_operand" "m"))
    (set (cc0) (match_operand:SI 2 "register_operand" "r"))]
  "operands[2] == operands[0]"
    "ld%0\\t%1\\t;movsi: %1 -> R:%0 w/ implied test of %2")

;; Optimize the case of following a register store with a test
;; of reg or mem just moved.

(define_peephole
  [(set (match_operand:HI 0 "memory_operand" "=m")
  (match_operand:HI 1 "register_operand" "r"))
   (set (cc0) (match_operand:HI 2 "general_operand" "g"))]
  "operands[2] == operands[0] || operands[2] == operands[1]"
    "st%1\\t%0\\t;movhi: R:%1 -> %0 w/ implied test of %2")
    
;; Optimize the (strange) case of following an SI register store
;; with a load of the reg just moved.
(define_peephole
  [(set (match_operand:SI 0 "memory_operand" "=m")
  (match_operand:SI 1 "register_operand" "r"))
  (set (match_operand:SI 2 "register_operand" "=r")
  (match_operand:SI 3 "memory_operand" "m"))]
  "operands[0] == operands[3] && operands[1] == operands[2]"
    "st%1\\t%0\\t;movsi: R:%1 -> %0 w/ redundant move of %3 -> %2")
    
;; Optimize the (strange) case of following an HI register store
;; with a load of the reg just moved.
(define_peephole
  [(set (match_operand:HI 0 "memory_operand" "=m")
  (match_operand:HI 1 "register_operand" "r"))
  (set (match_operand:HI 2 "register_operand" "=r")
  (match_operand:HI 3 "memory_operand" "m"))]
  "operands[0] == operands[3] && operands[1] == operands[2]"
    "st%1\\t%0\\t;movhi: R:%1 -> %0 w/ redundant move of %3 -> %2")
  
;; Optimize two consecutive constant QI stores to the memory.
;; Ordinarily these comes out as LDB/STB/LDB/STB, but we can
;; coalesce the constants as emit as a single LDD/STD.
(define_peephole
  [
    (set (match_operand:QI 0 "register_operand" "=q")
      (match_operand:QI 1 "immediate_operand" "K"))
    (set (match_operand:QI 2 "push_operand" "=m")
      (match_operand:QI 3 "register_operand" "0"))
    (set (match_operand:QI 4 "register_operand" "=0")
      (match_operand:QI 5 "immediate_operand" "K"))
    (set (match_operand:QI 6 "push_operand" "=m")
      (match_operand:QI 7 "register_operand" "0"))
  ]
  ""
{
  rtx xoperands[1];

  xoperands[0] = gen_rtx (CONST_INT, HImode, 
    (INTVAL (operands[5]) << 8) + INTVAL (operands[1]));

  output_asm_insn ("ldd\\t%0\\t;peephole: two constant byte pushes\;std\\t,--s", xoperands);
  return \"\";
})


;;- mode:emacs-lisp
;;- comment-start: ";;- "
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))
;;- eval: (modify-syntax-entry ?[ "(]")
;;- eval: (modify-syntax-entry ?] ")[")
;;- eval: (modify-syntax-entry ?{ "(}")
;;- eval: (modify-syntax-entry ?} "){")
;-; vim: set ts=2:
;-; vim: set expandtab:
;-; vim: set filetype=: 
;;- End:
